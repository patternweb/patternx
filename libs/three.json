[
  {
    "name": "AnimationAction",
    "type": "typeof AnimationAction",
    "constructors": [
      {
        "returnType": "AnimationAction"
      }
    ],
    "properties": [
      {
        "name": "time",
        "type": "number"
      },
      {
        "name": "timeScale",
        "type": "number"
      },
      {
        "name": "weight",
        "type": "number"
      },
      {
        "name": "repetitions",
        "type": "number"
      },
      {
        "name": "paused",
        "type": "boolean"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "clampWhenFinished",
        "type": "boolean"
      },
      {
        "name": "zeroSlopeAtStart",
        "type": "boolean"
      },
      {
        "name": "zeroSlopeAtEnd",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "play",
        "type": "() => AnimationAction"
      },
      {
        "name": "stop",
        "type": "() => AnimationAction"
      },
      {
        "name": "reset",
        "type": "() => AnimationAction"
      },
      {
        "name": "isRunning",
        "type": "() => boolean"
      },
      {
        "name": "startAt",
        "type": "(time: number) => AnimationAction"
      },
      {
        "name": "setLoop",
        "type": "(mode: AnimationActionLoopStyles, repetitions: number) => AnimationAction"
      },
      {
        "name": "setEffectiveWeight",
        "type": "(weight: number) => AnimationAction"
      },
      {
        "name": "getEffectiveWeight",
        "type": "() => number"
      },
      {
        "name": "fadeIn",
        "type": "(duration: number) => AnimationAction"
      },
      {
        "name": "fadeOut",
        "type": "(duration: number) => AnimationAction"
      },
      {
        "name": "crossFadeFrom",
        "type": "(fadeOutAction: AnimationAction, duration: number, warp: boolean) => AnimationAction"
      },
      {
        "name": "crossFadeTo",
        "type": "(fadeInAction: AnimationAction, duration: number, warp: boolean) => AnimationAction"
      },
      {
        "name": "stopFading",
        "type": "() => AnimationAction"
      },
      {
        "name": "setEffectiveTimeScale",
        "type": "(timeScale: number) => AnimationAction"
      },
      {
        "name": "getEffectiveTimeScale",
        "type": "() => number"
      },
      {
        "name": "setDuration",
        "type": "(duration: number) => AnimationAction"
      },
      {
        "name": "syncWith",
        "type": "(action: AnimationAction) => AnimationAction"
      },
      {
        "name": "halt",
        "type": "(duration: number) => AnimationAction"
      },
      {
        "name": "warp",
        "type": "(statTimeScale: number, endTimeScale: number, duration: number) => AnimationAction"
      },
      {
        "name": "stopWarping",
        "type": "() => AnimationAction"
      },
      {
        "name": "getMixer",
        "type": "() => AnimationMixer"
      },
      {
        "name": "getClip",
        "type": "() => AnimationClip"
      },
      {
        "name": "getRoot",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "AnimationClip",
    "type": "typeof AnimationClip",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name?",
            "type": "string"
          },
          {
            "name": "duration?",
            "type": "number"
          },
          {
            "name": "tracks?",
            "type": "KeyframeTrack[]"
          }
        ],
        "returnType": "AnimationClip"
      }
    ],
    "properties": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "duration",
        "type": "number"
      },
      {
        "name": "uuid",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "tracks",
        "type": "KeyframeTrack[]"
      },
      {
        "name": "results",
        "type": "any[]"
      },
      {
        "name": "resetDuration",
        "type": "() => void"
      },
      {
        "name": "trim",
        "type": "() => AnimationClip"
      },
      {
        "name": "optimize",
        "type": "() => AnimationClip"
      }
    ]
  },
  {
    "name": "AnimationMixer",
    "type": "typeof AnimationMixer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "root",
            "type": "any"
          }
        ],
        "returnType": "AnimationMixer"
      }
    ],
    "properties": [
      {
        "name": "time",
        "type": "number"
      },
      {
        "name": "timeScale",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "clipAction",
        "type": "(clip: AnimationClip, root?: any) => AnimationAction"
      },
      {
        "name": "existingAction",
        "type": "(clip: AnimationClip, root?: any) => AnimationAction"
      },
      {
        "name": "stopAllAction",
        "type": "(clip: AnimationClip, root?: any) => AnimationMixer"
      },
      {
        "name": "update",
        "type": "(deltaTime: number) => AnimationMixer"
      },
      {
        "name": "getRoot",
        "type": "() => any"
      },
      {
        "name": "uncacheClip",
        "type": "(clip: AnimationClip) => void"
      },
      {
        "name": "uncacheRoot",
        "type": "(root: any) => void"
      },
      {
        "name": "uncacheAction",
        "type": "(clip: AnimationClip, root?: any) => void"
      }
    ]
  },
  {
    "name": "AnimationObjectGroup",
    "type": "typeof AnimationObjectGroup",
    "constructors": [
      {
        "parameters": [
          {
            "name": "args",
            "type": "any[]"
          }
        ],
        "returnType": "AnimationObjectGroup"
      }
    ],
    "properties": [
      {
        "name": "uuid",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "stats",
        "type": "{ bindingsPerObject: number; objects: { total: number; inUse: number; }; }"
      },
      {
        "name": "add",
        "type": "(...args: any[]) => void"
      },
      {
        "name": "remove",
        "type": "(...args: any[]) => void"
      },
      {
        "name": "uncache",
        "type": "(...args: any[]) => void"
      }
    ]
  },
  {
    "name": "KeyframeTrack",
    "type": "typeof KeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "KeyframeTrack"
      }
    ],
    "properties": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "ValueTypeName",
        "type": "string"
      },
      {
        "name": "TimeBufferType",
        "type": "Float32Array"
      },
      {
        "name": "ValueBufferType",
        "type": "Float32Array"
      },
      {
        "name": "DefaultInterpolation",
        "type": "InterpolationModes"
      }
    ],
    "methods": [
      {
        "name": "times",
        "type": "any[]"
      },
      {
        "name": "values",
        "type": "any[]"
      },
      {
        "name": "InterpolantFactoryMethodDiscrete",
        "type": "(result: any) => DiscreteInterpolant"
      },
      {
        "name": "InterpolantFactoryMethodLinear",
        "type": "(result: any) => LinearInterpolant"
      },
      {
        "name": "InterpolantFactoryMethodSmooth",
        "type": "(result: any) => CubicInterpolant"
      },
      {
        "name": "setInterpolation",
        "type": "(interpolation: InterpolationModes) => void"
      },
      {
        "name": "getInterpolation",
        "type": "() => InterpolationModes"
      },
      {
        "name": "getValuesize",
        "type": "() => number"
      },
      {
        "name": "shift",
        "type": "(timeOffset: number) => KeyframeTrack"
      },
      {
        "name": "scale",
        "type": "(timeScale: number) => KeyframeTrack"
      },
      {
        "name": "trim",
        "type": "(startTime: number, endTime: number) => KeyframeTrack"
      },
      {
        "name": "validate",
        "type": "() => boolean"
      },
      {
        "name": "optimize",
        "type": "() => KeyframeTrack"
      }
    ]
  },
  {
    "name": "PropertyBinding",
    "type": "typeof PropertyBinding",
    "constructors": [
      {
        "parameters": [
          {
            "name": "rootNode",
            "type": "any"
          },
          {
            "name": "path",
            "type": "string"
          },
          {
            "name": "parsedPath?",
            "type": "any"
          }
        ],
        "returnType": "PropertyBinding"
      }
    ],
    "properties": [
      {
        "name": "path",
        "type": "string"
      },
      {
        "name": "parsedPath",
        "type": "any"
      },
      {
        "name": "node",
        "type": "any"
      },
      {
        "name": "rootNode",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "getValue",
        "type": "(targetArray: any, offset: number) => any"
      },
      {
        "name": "setValue",
        "type": "(sourceArray: any, offset: number) => void"
      },
      {
        "name": "bind",
        "type": "() => void"
      },
      {
        "name": "unbind",
        "type": "() => void"
      },
      {
        "name": "BindingType",
        "type": "{ [bindingType: string]: number; }"
      },
      {
        "name": "Versioning",
        "type": "{ [versioning: string]: number; }"
      },
      {
        "name": "GetterByBindingType",
        "type": "Function[]"
      },
      {
        "name": "SetterByBindingTypeAndVersioning",
        "type": "Function[][]"
      }
    ]
  },
  {
    "name": "Composite",
    "type": "typeof Composite",
    "constructors": [
      {
        "parameters": [
          {
            "name": "targetGroup",
            "type": "any"
          },
          {
            "name": "path",
            "type": "any"
          },
          {
            "name": "parsedPath?",
            "type": "any"
          }
        ],
        "returnType": "Composite"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "getValue",
        "type": "(array: any, offset: number) => any"
      },
      {
        "name": "setValue",
        "type": "(array: any, offset: number) => void"
      },
      {
        "name": "bind",
        "type": "() => void"
      },
      {
        "name": "unbind",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "PropertyMixer",
    "type": "typeof PropertyMixer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "binding",
            "type": "any"
          },
          {
            "name": "typeName",
            "type": "string"
          },
          {
            "name": "valueSize",
            "type": "number"
          }
        ],
        "returnType": "PropertyMixer"
      }
    ],
    "properties": [
      {
        "name": "binding",
        "type": "any"
      },
      {
        "name": "valueSize",
        "type": "number"
      },
      {
        "name": "buffer",
        "type": "any"
      },
      {
        "name": "cumulativeWeight",
        "type": "number"
      },
      {
        "name": "useCount",
        "type": "number"
      },
      {
        "name": "referenceCount",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "accumulate",
        "type": "(accuIndex: number, weight: number) => void"
      },
      {
        "name": "apply",
        "type": "(accuIndex: number) => void"
      },
      {
        "name": "saveOriginalState",
        "type": "() => void"
      },
      {
        "name": "restoreOriginalState",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "BooleanKeyframeTrack",
    "type": "typeof BooleanKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          }
        ],
        "returnType": "BooleanKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ColorKeyframeTrack",
    "type": "typeof ColorKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "ColorKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "NumberKeyframeTrack",
    "type": "typeof NumberKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "NumberKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "QuaternionKeyframeTrack",
    "type": "typeof QuaternionKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "QuaternionKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "StringKeyframeTrack",
    "type": "typeof StringKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "StringKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "VectorKeyframeTrack",
    "type": "typeof VectorKeyframeTrack",
    "constructors": [
      {
        "parameters": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "times",
            "type": "any[]"
          },
          {
            "name": "values",
            "type": "any[]"
          },
          {
            "name": "interpolation",
            "type": "InterpolationModes"
          }
        ],
        "returnType": "VectorKeyframeTrack"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Camera",
    "type": "typeof Camera",
    "documentation": "Abstract base class for cameras. This class should always be inherited when you build a new camera.",
    "constructors": [
      {
        "documentation": "This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.",
        "returnType": "Camera"
      }
    ],
    "properties": [
      {
        "name": "matrixWorldInverse",
        "type": "Matrix4",
        "documentation": "This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera."
      },
      {
        "name": "projectionMatrix",
        "type": "Matrix4",
        "documentation": "This is the matrix which contains the projection."
      }
    ],
    "methods": [
      {
        "name": "getWorldDirection",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "lookAt",
        "type": "(vector: Vector3) => void",
        "documentation": "This make the camera look at the vector position in local space."
      }
    ]
  },
  {
    "name": "CubeCamera",
    "type": "typeof CubeCamera",
    "constructors": [
      {
        "parameters": [
          {
            "name": "near?",
            "type": "number"
          },
          {
            "name": "far?",
            "type": "number"
          },
          {
            "name": "cubeResolution?",
            "type": "number"
          }
        ],
        "returnType": "CubeCamera"
      }
    ],
    "properties": [
      {
        "name": "renderTarget",
        "type": "WebGLRenderTargetCube"
      }
    ],
    "methods": [
      {
        "name": "updateCubeMap",
        "type": "(renderer: Renderer, scene: Scene) => void"
      }
    ]
  },
  {
    "name": "OrthographicCamera",
    "type": "typeof OrthographicCamera",
    "documentation": "Camera with orthographic projection",
    "constructors": [
      {
        "parameters": [
          {
            "name": "left",
            "type": "number",
            "documentation": "Camera frustum left plane."
          },
          {
            "name": "right",
            "type": "number",
            "documentation": "Camera frustum right plane."
          },
          {
            "name": "top",
            "type": "number",
            "documentation": "Camera frustum top plane."
          },
          {
            "name": "bottom",
            "type": "number",
            "documentation": "Camera frustum bottom plane."
          },
          {
            "name": "near?",
            "type": "number",
            "documentation": "Camera frustum near plane."
          },
          {
            "name": "far?",
            "type": "number",
            "documentation": "Camera frustum far plane."
          }
        ],
        "returnType": "OrthographicCamera"
      }
    ],
    "properties": [
      {
        "name": "zoom",
        "type": "number"
      },
      {
        "name": "left",
        "type": "number",
        "documentation": "Camera frustum left plane."
      },
      {
        "name": "right",
        "type": "number",
        "documentation": "Camera frustum right plane."
      },
      {
        "name": "top",
        "type": "number",
        "documentation": "Camera frustum top plane."
      },
      {
        "name": "bottom",
        "type": "number",
        "documentation": "Camera frustum bottom plane."
      },
      {
        "name": "near",
        "type": "number",
        "documentation": "Camera frustum near plane."
      },
      {
        "name": "far",
        "type": "number",
        "documentation": "Camera frustum far plane."
      }
    ],
    "methods": [
      {
        "name": "view",
        "type": "{ fullWidth: number; fullHeight: number; offsetX: number; offsetY: number; width: number; height:..."
      },
      {
        "name": "updateProjectionMatrix",
        "type": "() => void",
        "documentation": "Updates the camera projection matrix. Must be called after change of parameters."
      },
      {
        "name": "setViewOffset",
        "type": "(fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: ..."
      },
      {
        "name": "clearViewOffset",
        "type": "() => void"
      },
      {
        "name": "toJSON",
        "type": "(meta?: any) => any"
      }
    ]
  },
  {
    "name": "PerspectiveCamera",
    "type": "typeof PerspectiveCamera",
    "documentation": "Camera with perspective projection.\r\n\r\n# example\r\n     var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );\r\n     scene.add( camera );",
    "constructors": [
      {
        "parameters": [
          {
            "name": "fov?",
            "type": "number",
            "documentation": "Camera frustum vertical field of view. Default value is 50."
          },
          {
            "name": "aspect?",
            "type": "number",
            "documentation": "Camera frustum aspect ratio. Default value is 1."
          },
          {
            "name": "near?",
            "type": "number",
            "documentation": "Camera frustum near plane. Default value is 0.1."
          },
          {
            "name": "far?",
            "type": "number",
            "documentation": "Camera frustum far plane. Default value is 2000."
          }
        ],
        "returnType": "PerspectiveCamera"
      }
    ],
    "properties": [
      {
        "name": "zoom",
        "type": "number"
      },
      {
        "name": "fov",
        "type": "number",
        "documentation": "Camera frustum vertical field of view, from bottom to top of view, in degrees."
      },
      {
        "name": "aspect",
        "type": "number",
        "documentation": "Camera frustum aspect ratio, window width divided by window height."
      },
      {
        "name": "near",
        "type": "number",
        "documentation": "Camera frustum near plane."
      },
      {
        "name": "far",
        "type": "number",
        "documentation": "Camera frustum far plane."
      },
      {
        "name": "focus",
        "type": "number"
      },
      {
        "name": "filmGauge",
        "type": "number"
      },
      {
        "name": "filmOffset",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "view",
        "type": "{ fullWidth: number; fullHeight: number; offsetX: number; offsetY: number; width: number; height:..."
      },
      {
        "name": "setFocalLength",
        "type": "(focalLength: number) => void"
      },
      {
        "name": "getFocalLength",
        "type": "() => number"
      },
      {
        "name": "getEffectiveFOV",
        "type": "() => number"
      },
      {
        "name": "getFilmWidth",
        "type": "() => number"
      },
      {
        "name": "getFilmHeight",
        "type": "() => number"
      },
      {
        "name": "setViewOffset",
        "type": "(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) => v...",
        "documentation": "Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.\r\nFor example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:\r\n\r\n     +---+---+---+\r\n     | A | B | C |\r\n     +---+---+---+\r\n     | D | E | F |\r\n     +---+---+---+\r\n\r\nthen for each monitor you would call it like this:\r\n\r\n     var w = 1920;\r\n     var h = 1080;\r\n     var fullWidth = w * 3;\r\n     var fullHeight = h * 2;\r\n\r\n     // A\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n     // B\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n     // C\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n     // D\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n     // E\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n     // F\r\n     camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid."
      },
      {
        "name": "clearViewOffset",
        "type": "() => void"
      },
      {
        "name": "updateProjectionMatrix",
        "type": "() => void",
        "documentation": "Updates the camera projection matrix. Must be called after change of parameters."
      },
      {
        "name": "toJSON",
        "type": "(meta?: any) => any"
      },
      {
        "name": "setLens",
        "type": "(focalLength: number, frameHeight?: number) => void"
      }
    ]
  },
  {
    "name": "StereoCamera",
    "type": "typeof StereoCamera",
    "constructors": [
      {
        "returnType": "StereoCamera"
      }
    ],
    "properties": [
      {
        "name": "aspect",
        "type": "number"
      },
      {
        "name": "eyeSep",
        "type": "number"
      },
      {
        "name": "cameraL",
        "type": "PerspectiveCamera"
      },
      {
        "name": "cameraR",
        "type": "PerspectiveCamera"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "(camera: PerspectiveCamera) => void"
      }
    ]
  },
  {
    "name": "BufferAttribute",
    "type": "typeof BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number>"
          },
          {
            "name": "itemSize",
            "type": "number"
          },
          {
            "name": "normalized?",
            "type": "boolean"
          }
        ],
        "returnType": "BufferAttribute"
      }
    ],
    "properties": [
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "itemSize",
        "type": "number"
      },
      {
        "name": "dynamic",
        "type": "boolean"
      },
      {
        "name": "version",
        "type": "number"
      },
      {
        "name": "normalized",
        "type": "boolean"
      },
      {
        "name": "needsUpdate",
        "type": "boolean"
      },
      {
        "name": "count",
        "type": "number"
      },
      {
        "name": "length",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "array",
        "type": "ArrayLike<number>"
      },
      {
        "name": "updateRange",
        "type": "{ offset: number; count: number; }"
      },
      {
        "name": "setDynamic",
        "type": "(dynamic: boolean) => BufferAttribute"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "copyAt",
        "type": "(index1: number, attribute: BufferAttribute, index2: number) => BufferAttribute"
      },
      {
        "name": "copyArray",
        "type": "(array: ArrayLike<number>) => BufferAttribute"
      },
      {
        "name": "copyColorsArray",
        "type": "(colors: { r: number; g: number; b: number; }[]) => BufferAttribute"
      },
      {
        "name": "copyIndicesArray",
        "type": "(indices: { a: number; b: number; c: number; }[]) => BufferAttribute"
      },
      {
        "name": "copyVector2sArray",
        "type": "(vectors: { x: number; y: number; }[]) => BufferAttribute"
      },
      {
        "name": "copyVector3sArray",
        "type": "(vectors: { x: number; y: number; z: number; }[]) => BufferAttribute"
      },
      {
        "name": "copyVector4sArray",
        "type": "(vectors: { x: number; y: number; z: number; w: number; }[]) => BufferAttribute"
      },
      {
        "name": "set",
        "type": "(value: ArrayLike<number>, offset?: number) => BufferAttribute"
      },
      {
        "name": "getX",
        "type": "(index: number) => number"
      },
      {
        "name": "setX",
        "type": "(index: number, x: number) => BufferAttribute"
      },
      {
        "name": "getY",
        "type": "(index: number) => number"
      },
      {
        "name": "setY",
        "type": "(index: number, y: number) => BufferAttribute"
      },
      {
        "name": "getZ",
        "type": "(index: number) => number"
      },
      {
        "name": "setZ",
        "type": "(index: number, z: number) => BufferAttribute"
      },
      {
        "name": "getW",
        "type": "(index: number) => number"
      },
      {
        "name": "setW",
        "type": "(index: number, z: number) => BufferAttribute"
      },
      {
        "name": "setXY",
        "type": "(index: number, x: number, y: number) => BufferAttribute"
      },
      {
        "name": "setXYZ",
        "type": "(index: number, x: number, y: number, z: number) => BufferAttribute"
      },
      {
        "name": "setXYZW",
        "type": "(index: number, x: number, y: number, z: number, w: number) => BufferAttribute"
      }
    ]
  },
  {
    "name": "Int8Attribute",
    "type": "typeof Int8Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int8Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint8Attribute",
    "type": "typeof Uint8Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint8Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint8ClampedAttribute",
    "type": "typeof Uint8ClampedAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint8ClampedAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Int16Attribute",
    "type": "typeof Int16Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int16Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint16Attribute",
    "type": "typeof Uint16Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint16Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Int32Attribute",
    "type": "typeof Int32Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int32Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint32Attribute",
    "type": "typeof Uint32Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint32Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Float32Attribute",
    "type": "typeof Float32Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Float32Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Float64Attribute",
    "type": "typeof Float64Attribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "any"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Float64Attribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Int8BufferAttribute",
    "type": "typeof Int8BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int8BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint8BufferAttribute",
    "type": "typeof Uint8BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint8BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint8ClampedBufferAttribute",
    "type": "typeof Uint8ClampedBufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint8ClampedBufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Int16BufferAttribute",
    "type": "typeof Int16BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int16BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint16BufferAttribute",
    "type": "typeof Uint16BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint16BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Int32BufferAttribute",
    "type": "typeof Int32BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Int32BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uint32BufferAttribute",
    "type": "typeof Uint32BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Uint32BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Float32BufferAttribute",
    "type": "typeof Float32BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Float32BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Float64BufferAttribute",
    "type": "typeof Float64BufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number> | Iterable<number> | ArrayBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          }
        ],
        "returnType": "Float64BufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "DynamicBufferAttribute",
    "type": "typeof DynamicBufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number>"
          },
          {
            "name": "itemSize",
            "type": "number"
          },
          {
            "name": "normalized?",
            "type": "boolean"
          }
        ],
        "returnType": "DynamicBufferAttribute"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "BufferGeometry",
    "type": "typeof BufferGeometry",
    "documentation": "This is a superefficent class for geometries because it saves all data in buffers.\r\nIt reduces memory costs and cpu cycles. But it is not as easy to work with because of all the nessecary buffer calculations.\r\nIt is mainly interesting when working with static objects.",
    "constructors": [
      {
        "documentation": "This creates a new BufferGeometry. It also sets several properties to an default value.",
        "returnType": "BufferGeometry"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number",
        "documentation": "Unique number of this buffergeometry instance"
      },
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "index",
        "type": "BufferAttribute"
      },
      {
        "name": "morphAttributes",
        "type": "any"
      },
      {
        "name": "boundingBox",
        "type": "Box3"
      },
      {
        "name": "boundingSphere",
        "type": "Sphere"
      },
      {
        "name": "drawcalls",
        "type": "any"
      },
      {
        "name": "offsets",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "attributes",
        "type": "BufferAttribute | InterleavedBufferAttribute[]"
      },
      {
        "name": "groups",
        "type": "{ start: number; count: number; materialIndex?: number; }[]"
      },
      {
        "name": "drawRange",
        "type": "{ start: number; count: number; }"
      },
      {
        "name": "getIndex",
        "type": "() => BufferAttribute"
      },
      {
        "name": "setIndex",
        "type": "(index: BufferAttribute | number[]) => void"
      },
      {
        "name": "addAttribute",
        "type": "{ (name: string, attribute: BufferAttribute | InterleavedBufferAttribute): BufferGeometry; (name:..."
      },
      {
        "name": "getAttribute",
        "type": "(name: string) => BufferAttribute | InterleavedBufferAttribute"
      },
      {
        "name": "removeAttribute",
        "type": "(name: string) => BufferGeometry"
      },
      {
        "name": "addGroup",
        "type": "(start: number, count: number, materialIndex?: number) => void"
      },
      {
        "name": "clearGroups",
        "type": "() => void"
      },
      {
        "name": "setDrawRange",
        "type": "(start: number, count: number) => void"
      },
      {
        "name": "applyMatrix",
        "type": "(matrix: Matrix4) => BufferGeometry",
        "documentation": "Bakes matrix transform directly into vertex coordinates."
      },
      {
        "name": "rotateX",
        "type": "(angle: number) => BufferGeometry"
      },
      {
        "name": "rotateY",
        "type": "(angle: number) => BufferGeometry"
      },
      {
        "name": "rotateZ",
        "type": "(angle: number) => BufferGeometry"
      },
      {
        "name": "translate",
        "type": "(x: number, y: number, z: number) => BufferGeometry"
      },
      {
        "name": "scale",
        "type": "(x: number, y: number, z: number) => BufferGeometry"
      },
      {
        "name": "lookAt",
        "type": "(v: Vector3) => void"
      },
      {
        "name": "center",
        "type": "() => Vector3"
      },
      {
        "name": "setFromObject",
        "type": "(object: Object3D) => void"
      },
      {
        "name": "updateFromObject",
        "type": "(object: Object3D) => void"
      },
      {
        "name": "fromGeometry",
        "type": "(geometry: Geometry, settings?: any) => BufferGeometry"
      },
      {
        "name": "fromDirectGeometry",
        "type": "(geometry: DirectGeometry) => BufferGeometry"
      },
      {
        "name": "computeBoundingBox",
        "type": "() => void",
        "documentation": "Computes bounding box of the geometry, updating Geometry.boundingBox attribute.\r\nBounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null."
      },
      {
        "name": "computeBoundingSphere",
        "type": "() => void",
        "documentation": "Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.\r\nBounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null."
      },
      {
        "name": "computeVertexNormals",
        "type": "() => void",
        "documentation": "Computes vertex normals by averaging face normals."
      },
      {
        "name": "merge",
        "type": "(geometry: BufferGeometry, offset: number) => BufferGeometry"
      },
      {
        "name": "normalizeNormals",
        "type": "() => void"
      },
      {
        "name": "toNonIndexed",
        "type": "() => BufferGeometry"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "dispose",
        "type": "() => void",
        "documentation": "Disposes the object from memory.\r\nYou need to call this when you want the bufferGeometry removed while the application is running."
      },
      {
        "name": "addIndex",
        "type": "(index: any) => void"
      },
      {
        "name": "addDrawCall",
        "type": "(start: any, count: any, indexOffset?: any) => void"
      },
      {
        "name": "clearDrawCalls",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "Clock",
    "type": "typeof Clock",
    "documentation": "Object for keeping track of time.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "autoStart?",
            "type": "boolean",
            "documentation": "Automatically start the clock."
          }
        ],
        "returnType": "Clock"
      }
    ],
    "properties": [
      {
        "name": "autoStart",
        "type": "boolean",
        "documentation": "If set, starts the clock automatically when the first update is called."
      },
      {
        "name": "startTime",
        "type": "number",
        "documentation": "When the clock is running, It holds the starttime of the clock.\r\nThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
      },
      {
        "name": "oldTime",
        "type": "number",
        "documentation": "When the clock is running, It holds the previous time from a update.\r\nThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
      },
      {
        "name": "elapsedTime",
        "type": "number",
        "documentation": "When the clock is running, It holds the time elapsed between the start of the clock to the previous update.\r\nThis parameter is in seconds of three decimal places."
      },
      {
        "name": "running",
        "type": "boolean",
        "documentation": "This property keeps track whether the clock is running or not."
      }
    ],
    "methods": [
      {
        "name": "start",
        "type": "() => void",
        "documentation": "Starts clock."
      },
      {
        "name": "stop",
        "type": "() => void",
        "documentation": "Stops clock."
      },
      {
        "name": "getElapsedTime",
        "type": "() => number",
        "documentation": "Get the seconds passed since the clock started."
      },
      {
        "name": "getDelta",
        "type": "() => number",
        "documentation": "Get the seconds passed since the last call to this method."
      }
    ]
  },
  {
    "name": "DirectGeometry",
    "type": "typeof DirectGeometry",
    "constructors": [
      {
        "returnType": "DirectGeometry"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "boundingBox",
        "type": "Box3"
      },
      {
        "name": "boundingSphere",
        "type": "Sphere"
      },
      {
        "name": "verticesNeedUpdate",
        "type": "boolean"
      },
      {
        "name": "normalsNeedUpdate",
        "type": "boolean"
      },
      {
        "name": "colorsNeedUpdate",
        "type": "boolean"
      },
      {
        "name": "uvsNeedUpdate",
        "type": "boolean"
      },
      {
        "name": "groupsNeedUpdate",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "indices",
        "type": "number[]"
      },
      {
        "name": "vertices",
        "type": "Vector3[]"
      },
      {
        "name": "normals",
        "type": "Vector3[]"
      },
      {
        "name": "colors",
        "type": "Color[]"
      },
      {
        "name": "uvs",
        "type": "Vector2[]"
      },
      {
        "name": "uvs2",
        "type": "Vector2[]"
      },
      {
        "name": "groups",
        "type": "{ start: number; materialIndex: number; }[]"
      },
      {
        "name": "morphTargets",
        "type": "MorphTarget[]"
      },
      {
        "name": "skinWeights",
        "type": "number[]"
      },
      {
        "name": "skinIndices",
        "type": "number[]"
      },
      {
        "name": "computeBoundingBox",
        "type": "() => void"
      },
      {
        "name": "computeBoundingSphere",
        "type": "() => void"
      },
      {
        "name": "computeGroups",
        "type": "(geometry: Geometry) => void"
      },
      {
        "name": "fromGeometry",
        "type": "(geometry: Geometry) => DirectGeometry"
      },
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "addEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "hasEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "removeEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "dispatchEvent",
        "type": "(event: { [attachment: string]: any; type: string; }) => void"
      }
    ]
  },
  {
    "name": "EventDispatcher",
    "type": "typeof EventDispatcher",
    "documentation": "JavaScript events for custom objects\r\n\r\n# Example\r\n     var Car = function () {\r\n\r\n         EventDispatcher.call( this );\r\n         this.start = function () {\r\n\r\n             this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );\r\n\r\n         };\r\n\r\n     };\r\n\r\n     var car = new Car();\r\n     car.addEventListener( 'start', function ( event ) {\r\n\r\n         alert( event.message );\r\n\r\n     } );\r\n     car.start();",
    "constructors": [
      {
        "documentation": "Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.",
        "returnType": "EventDispatcher"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "addEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void",
        "documentation": "Adds a listener to an event type."
      },
      {
        "name": "hasEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void",
        "documentation": "Adds a listener to an event type."
      },
      {
        "name": "removeEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void",
        "documentation": "Removes a listener from an event type."
      },
      {
        "name": "dispatchEvent",
        "type": "(event: { [attachment: string]: any; type: string; }) => void",
        "documentation": "Fire an event type."
      }
    ]
  },
  {
    "name": "Event",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "target",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "Face3",
    "type": "typeof Face3",
    "documentation": "Triangle face.\r\n\r\n# Example\r\n     var normal = new THREE.Vector3( 0, 1, 0 );\r\n     var color = new THREE.Color( 0xffaa00 );\r\n     var face = new THREE.Face3( 0, 1, 2, normal, color, 0 );",
    "constructors": [
      {
        "parameters": [
          {
            "name": "a",
            "type": "number",
            "documentation": "Vertex A index."
          },
          {
            "name": "b",
            "type": "number",
            "documentation": "Vertex B index."
          },
          {
            "name": "c",
            "type": "number",
            "documentation": "Vertex C index."
          },
          {
            "name": "normal?",
            "type": "Vector3",
            "documentation": "Face normal or array of vertex normals."
          },
          {
            "name": "color?",
            "type": "Color",
            "documentation": "Face color or array of vertex colors."
          },
          {
            "name": "materialIndex?",
            "type": "number",
            "documentation": "Material index."
          }
        ],
        "returnType": "Face3"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "normal?",
            "type": "Vector3"
          },
          {
            "name": "vertexColors?",
            "type": "Color[]"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face3"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "vertexNormals?",
            "type": "Vector3[]"
          },
          {
            "name": "color?",
            "type": "Color"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face3"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "vertexNormals?",
            "type": "Vector3[]"
          },
          {
            "name": "vertexColors?",
            "type": "Color[]"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face3"
      }
    ],
    "properties": [
      {
        "name": "a",
        "type": "number",
        "documentation": "Vertex A index."
      },
      {
        "name": "b",
        "type": "number",
        "documentation": "Vertex B index."
      },
      {
        "name": "c",
        "type": "number",
        "documentation": "Vertex C index."
      },
      {
        "name": "normal",
        "type": "Vector3",
        "documentation": "Face normal."
      },
      {
        "name": "color",
        "type": "Color",
        "documentation": "Face color."
      },
      {
        "name": "materialIndex",
        "type": "number",
        "documentation": "Material index (points to {@link Geometry.materials})."
      }
    ],
    "methods": [
      {
        "name": "vertexNormals",
        "type": "Vector3[]",
        "documentation": "Array of 4 vertex normals."
      },
      {
        "name": "vertexColors",
        "type": "Color[]",
        "documentation": "Array of 4 vertex normals."
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      }
    ]
  },
  {
    "name": "Face4",
    "type": "typeof Face4",
    "constructors": [
      {
        "parameters": [
          {
            "name": "a",
            "type": "number",
            "documentation": "Vertex A index."
          },
          {
            "name": "b",
            "type": "number",
            "documentation": "Vertex B index."
          },
          {
            "name": "c",
            "type": "number",
            "documentation": "Vertex C index."
          },
          {
            "name": "normal?",
            "type": "Vector3",
            "documentation": "Face normal or array of vertex normals."
          },
          {
            "name": "color?",
            "type": "Color",
            "documentation": "Face color or array of vertex colors."
          },
          {
            "name": "materialIndex?",
            "type": "number",
            "documentation": "Material index."
          }
        ],
        "returnType": "Face4"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "normal?",
            "type": "Vector3"
          },
          {
            "name": "vertexColors?",
            "type": "Color[]"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face4"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "vertexNormals?",
            "type": "Vector3[]"
          },
          {
            "name": "color?",
            "type": "Color"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face4"
      },
      {
        "parameters": [
          {
            "name": "a",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          },
          {
            "name": "c",
            "type": "number"
          },
          {
            "name": "vertexNormals?",
            "type": "Vector3[]"
          },
          {
            "name": "vertexColors?",
            "type": "Color[]"
          },
          {
            "name": "materialIndex?",
            "type": "number"
          }
        ],
        "returnType": "Face4"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "MorphTarget",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "vertices",
        "type": "Vector3[]"
      }
    ]
  },
  {
    "name": "MorphColor",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "colors",
        "type": "Color[]"
      }
    ]
  },
  {
    "name": "MorphNormals",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "normals",
        "type": "Vector3[]"
      }
    ]
  },
  {
    "name": "Geometry",
    "type": "typeof Geometry",
    "documentation": "Base class for geometries\r\n\r\n# Example\r\n     var geometry = new THREE.Geometry();\r\n     geometry.vertices.push( new THREE.Vector3( -10, 10, 0 ) );\r\n     geometry.vertices.push( new THREE.Vector3( -10, -10, 0 ) );\r\n     geometry.vertices.push( new THREE.Vector3( 10, -10, 0 ) );\r\n     geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );\r\n     geometry.computeBoundingSphere();",
    "constructors": [
      {
        "returnType": "Geometry"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number",
        "documentation": "Unique number of this geometry instance"
      },
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Name for this geometry. Default is an empty string."
      },
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "boundingBox",
        "type": "Box3",
        "documentation": "Bounding box."
      },
      {
        "name": "boundingSphere",
        "type": "Sphere",
        "documentation": "Bounding sphere."
      },
      {
        "name": "verticesNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the vertices array has been updated."
      },
      {
        "name": "elementsNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the faces array has been updated."
      },
      {
        "name": "uvsNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the uvs array has been updated."
      },
      {
        "name": "normalsNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the normals array has been updated."
      },
      {
        "name": "colorsNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the colors array has been updated."
      },
      {
        "name": "lineDistancesNeedUpdate",
        "type": "boolean",
        "documentation": "Set to true if the linedistances array has been updated."
      },
      {
        "name": "groupsNeedUpdate",
        "type": "boolean"
      },
      {
        "name": "animation",
        "type": "AnimationClip"
      }
    ],
    "methods": [
      {
        "name": "vertices",
        "type": "Vector3[]",
        "documentation": "The array of vertices hold every position of points of the model.\r\nTo signal an update in this array, Geometry.verticesNeedUpdate needs to be set to true."
      },
      {
        "name": "colors",
        "type": "Color[]",
        "documentation": "Array of vertex colors, matching number and order of vertices.\r\nUsed in ParticleSystem, Line and Ribbon.\r\nMeshes use per-face-use-of-vertex colors embedded directly in faces.\r\nTo signal an update in this array, Geometry.colorsNeedUpdate needs to be set to true."
      },
      {
        "name": "faces",
        "type": "Face3[]",
        "documentation": "Array of triangles or/and quads.\r\nThe array of faces describe how each vertex in the model is connected with each other.\r\nTo signal an update in this array, Geometry.elementsNeedUpdate needs to be set to true."
      },
      {
        "name": "faceVertexUvs",
        "type": "Vector2[][][]",
        "documentation": "Array of face UV layers.\r\nEach UV layer is an array of UV matching order and number of vertices in faces.\r\nTo signal an update in this array, Geometry.uvsNeedUpdate needs to be set to true."
      },
      {
        "name": "morphTargets",
        "type": "MorphTarget[]",
        "documentation": "Array of morph targets. Each morph target is a Javascript object:\r\n\r\n     { name: \"targetName\", vertices: [ new THREE.Vector3(), ... ] }\r\n\r\nMorph vertices match number and order of primary vertices."
      },
      {
        "name": "morphNormals",
        "type": "MorphNormals[]",
        "documentation": "Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:\r\n\r\n     morphNormal = { name: \"NormalName\", normals: [ new THREE.Vector3(), ... ] }"
      },
      {
        "name": "skinWeights",
        "type": "number[]",
        "documentation": "Array of skinning weights, matching number and order of vertices."
      },
      {
        "name": "skinIndices",
        "type": "number[]",
        "documentation": "Array of skinning indices, matching number and order of vertices."
      },
      {
        "name": "lineDistances",
        "type": "number[]"
      },
      {
        "name": "applyMatrix",
        "type": "(matrix: Matrix4) => Geometry",
        "documentation": "Bakes matrix transform directly into vertex coordinates."
      },
      {
        "name": "rotateX",
        "type": "(angle: number) => Geometry"
      },
      {
        "name": "rotateY",
        "type": "(angle: number) => Geometry"
      },
      {
        "name": "rotateZ",
        "type": "(angle: number) => Geometry"
      },
      {
        "name": "translate",
        "type": "(x: number, y: number, z: number) => Geometry"
      },
      {
        "name": "scale",
        "type": "(x: number, y: number, z: number) => Geometry"
      },
      {
        "name": "lookAt",
        "type": "(vector: Vector3) => void"
      },
      {
        "name": "fromBufferGeometry",
        "type": "(geometry: BufferGeometry) => Geometry"
      },
      {
        "name": "center",
        "type": "() => Vector3"
      },
      {
        "name": "normalize",
        "type": "() => Geometry"
      },
      {
        "name": "computeFaceNormals",
        "type": "() => void",
        "documentation": "Computes face normals."
      },
      {
        "name": "computeVertexNormals",
        "type": "(areaWeighted?: boolean) => void",
        "documentation": "Computes vertex normals by averaging face normals.\r\nFace normals must be existing / computed beforehand."
      },
      {
        "name": "computeFlatVertexNormals",
        "type": "() => void",
        "documentation": "Compute vertex normals, but duplicating face normals."
      },
      {
        "name": "computeMorphNormals",
        "type": "() => void",
        "documentation": "Computes morph normals."
      },
      {
        "name": "computeLineDistances",
        "type": "() => void"
      },
      {
        "name": "computeBoundingBox",
        "type": "() => void",
        "documentation": "Computes bounding box of the geometry, updating {@link Geometry.boundingBox} attribute."
      },
      {
        "name": "computeBoundingSphere",
        "type": "() => void",
        "documentation": "Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.\r\nNeither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are null."
      },
      {
        "name": "merge",
        "type": "(geometry: Geometry, matrix?: Matrix, materialIndexOffset?: number) => void"
      },
      {
        "name": "mergeMesh",
        "type": "(mesh: Mesh) => void"
      },
      {
        "name": "mergeVertices",
        "type": "() => number",
        "documentation": "Checks for duplicate vertices using hashmap.\r\nDuplicated vertices are removed and faces' vertices are updated."
      },
      {
        "name": "sortFacesByMaterialIndex",
        "type": "() => void"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Creates a new clone of the Geometry."
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "dispose",
        "type": "() => void",
        "documentation": "Removes The object from memory.\r\nDon't forget to call this method when you remove an geometry because it can cuase meomory leaks."
      },
      {
        "name": "bones",
        "type": "Bone[]"
      },
      {
        "name": "animations",
        "type": "AnimationClip[]"
      },
      {
        "name": "addEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "hasEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "removeEventListener",
        "type": "(type: string, listener: (event: Event) => void) => void"
      },
      {
        "name": "dispatchEvent",
        "type": "(event: { [attachment: string]: any; type: string; }) => void"
      }
    ]
  },
  {
    "name": "InstancedBufferAttribute",
    "type": "typeof InstancedBufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "data",
            "type": "ArrayLike<number>"
          },
          {
            "name": "itemSize",
            "type": "number"
          },
          {
            "name": "meshPerAttribute?",
            "type": "number"
          }
        ],
        "returnType": "InstancedBufferAttribute"
      }
    ],
    "properties": [
      {
        "name": "meshPerAttribute",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "InstancedBufferGeometry",
    "type": "typeof InstancedBufferGeometry",
    "constructors": [
      {
        "returnType": "InstancedBufferGeometry"
      }
    ],
    "properties": [
      {
        "name": "maxInstancedCount",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "groups",
        "type": "{ start: number; count: number; instances: number; }[]"
      },
      {
        "name": "addGroup",
        "type": "(start: number, count: number, instances: number) => void"
      }
    ]
  },
  {
    "name": "InterleavedBuffer",
    "type": "typeof InterleavedBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number>"
          },
          {
            "name": "stride",
            "type": "number"
          }
        ],
        "returnType": "InterleavedBuffer"
      }
    ],
    "properties": [
      {
        "name": "stride",
        "type": "number"
      },
      {
        "name": "dynamic",
        "type": "boolean"
      },
      {
        "name": "version",
        "type": "number"
      },
      {
        "name": "length",
        "type": "number"
      },
      {
        "name": "count",
        "type": "number"
      },
      {
        "name": "needsUpdate",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "array",
        "type": "ArrayLike<number>"
      },
      {
        "name": "updateRange",
        "type": "{ offset: number; count: number; }"
      },
      {
        "name": "setDynamic",
        "type": "(dynamic: boolean) => InterleavedBuffer"
      },
      {
        "name": "clone",
        "type": "{ (): this; (): this; }"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "copyAt",
        "type": "(index1: number, attribute: InterleavedBufferAttribute, index2: number) => InterleavedBuffer"
      },
      {
        "name": "set",
        "type": "(value: ArrayLike<number>, index: number) => InterleavedBuffer"
      }
    ]
  },
  {
    "name": "InstancedInterleavedBuffer",
    "type": "typeof InstancedInterleavedBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "array",
            "type": "ArrayLike<number>"
          },
          {
            "name": "stride",
            "type": "number"
          },
          {
            "name": "meshPerAttribute?",
            "type": "number"
          }
        ],
        "returnType": "InstancedInterleavedBuffer"
      }
    ],
    "properties": [
      {
        "name": "meshPerAttribute",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "InterleavedBufferAttribute",
    "type": "typeof InterleavedBufferAttribute",
    "constructors": [
      {
        "parameters": [
          {
            "name": "interleavedBuffer",
            "type": "InterleavedBuffer"
          },
          {
            "name": "itemSize",
            "type": "number"
          },
          {
            "name": "offset",
            "type": "number"
          },
          {
            "name": "normalized",
            "type": "boolean"
          }
        ],
        "returnType": "InterleavedBufferAttribute"
      }
    ],
    "properties": [
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "data",
        "type": "InterleavedBuffer"
      },
      {
        "name": "itemSize",
        "type": "number"
      },
      {
        "name": "offset",
        "type": "number"
      },
      {
        "name": "count",
        "type": "number"
      },
      {
        "name": "normalized",
        "type": "boolean"
      },
      {
        "name": "length",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "array",
        "type": "any[]"
      },
      {
        "name": "getX",
        "type": "(index: number) => number"
      },
      {
        "name": "setX",
        "type": "(index: number, x: number) => InterleavedBufferAttribute"
      },
      {
        "name": "getY",
        "type": "(index: number) => number"
      },
      {
        "name": "setY",
        "type": "(index: number, y: number) => InterleavedBufferAttribute"
      },
      {
        "name": "getZ",
        "type": "(index: number) => number"
      },
      {
        "name": "setZ",
        "type": "(index: number, z: number) => InterleavedBufferAttribute"
      },
      {
        "name": "getW",
        "type": "(index: number) => number"
      },
      {
        "name": "setW",
        "type": "(index: number, z: number) => InterleavedBufferAttribute"
      },
      {
        "name": "setXY",
        "type": "(index: number, x: number, y: number) => InterleavedBufferAttribute"
      },
      {
        "name": "setXYZ",
        "type": "(index: number, x: number, y: number, z: number) => InterleavedBufferAttribute"
      },
      {
        "name": "setXYZW",
        "type": "(index: number, x: number, y: number, z: number, w: number) => InterleavedBufferAttribute"
      }
    ]
  },
  {
    "name": "Object3D",
    "type": "typeof Object3D",
    "documentation": "Base class for scene graph objects",
    "constructors": [
      {
        "returnType": "Object3D"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number",
        "documentation": "Unique number of this object instance."
      },
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Optional name of the object (doesn't need to be unique)."
      },
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "parent",
        "type": "Object3D",
        "documentation": "Object's parent in the scene graph."
      },
      {
        "name": "up",
        "type": "Vector3",
        "documentation": "Up direction."
      },
      {
        "name": "position",
        "type": "Vector3",
        "documentation": "Object's local position."
      },
      {
        "name": "rotation",
        "type": "Euler",
        "documentation": "Object's local rotation (Euler angles), in radians."
      },
      {
        "name": "quaternion",
        "type": "Quaternion",
        "documentation": "Global rotation."
      },
      {
        "name": "scale",
        "type": "Vector3",
        "documentation": "Object's local scale."
      },
      {
        "name": "modelViewMatrix",
        "type": "Matrix4"
      },
      {
        "name": "normalMatrix",
        "type": "Matrix3"
      },
      {
        "name": "matrix",
        "type": "Matrix4",
        "documentation": "Local transform."
      },
      {
        "name": "matrixWorld",
        "type": "Matrix4",
        "documentation": "The global transform of the object. If the Object3d has no parent, then it's identical to the local transform."
      },
      {
        "name": "matrixAutoUpdate",
        "type": "boolean",
        "documentation": "When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property."
      },
      {
        "name": "matrixWorldNeedsUpdate",
        "type": "boolean",
        "documentation": "When this is set, it calculates the matrixWorld in that frame and resets this property to false."
      },
      {
        "name": "layers",
        "type": "Layers"
      },
      {
        "name": "visible",
        "type": "boolean",
        "documentation": "Object gets rendered if true."
      },
      {
        "name": "castShadow",
        "type": "boolean",
        "documentation": "Gets rendered into shadow map."
      },
      {
        "name": "receiveShadow",
        "type": "boolean",
        "documentation": "Material gets baked in shadow receiving."
      },
      {
        "name": "frustumCulled",
        "type": "boolean",
        "documentation": "When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible."
      },
      {
        "name": "renderOrder",
        "type": "number"
      },
      {
        "name": "userData",
        "type": "any",
        "documentation": "An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned."
      },
      {
        "name": "eulerOrder",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "children",
        "type": "Object3D[]",
        "documentation": "Array with object's children."
      },
      {
        "name": "onBeforeRender",
        "type": "(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry | Geometry, mate...",
        "documentation": "Calls before rendering object"
      },
      {
        "name": "onAfterRender",
        "type": "(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry | Geometry, mate...",
        "documentation": "Calls after rendering object"
      },
      {
        "name": "applyMatrix",
        "type": "(matrix: Matrix4) => void",
        "documentation": "This updates the position, rotation and scale with the matrix."
      },
      {
        "name": "setRotationFromAxisAngle",
        "type": "(axis: Vector3, angle: number) => void"
      },
      {
        "name": "setRotationFromEuler",
        "type": "(euler: Euler) => void"
      },
      {
        "name": "setRotationFromMatrix",
        "type": "(m: Matrix4) => void"
      },
      {
        "name": "setRotationFromQuaternion",
        "type": "(q: Quaternion) => void"
      },
      {
        "name": "rotateOnAxis",
        "type": "(axis: Vector3, angle: number) => Object3D",
        "documentation": "Rotate an object along an axis in object space. The axis is assumed to be normalized."
      },
      {
        "name": "rotateX",
        "type": "(angle: number) => Object3D"
      },
      {
        "name": "rotateY",
        "type": "(angle: number) => Object3D"
      },
      {
        "name": "rotateZ",
        "type": "(angle: number) => Object3D"
      },
      {
        "name": "translateOnAxis",
        "type": "(axis: Vector3, distance: number) => Object3D"
      },
      {
        "name": "translateX",
        "type": "(distance: number) => Object3D",
        "documentation": "Translates object along x axis by distance."
      },
      {
        "name": "translateY",
        "type": "(distance: number) => Object3D",
        "documentation": "Translates object along y axis by distance."
      },
      {
        "name": "translateZ",
        "type": "(distance: number) => Object3D",
        "documentation": "Translates object along z axis by distance."
      },
      {
        "name": "localToWorld",
        "type": "(vector: Vector3) => Vector3",
        "documentation": "Updates the vector from local space to world space."
      },
      {
        "name": "worldToLocal",
        "type": "(vector: Vector3) => Vector3",
        "documentation": "Updates the vector from world space to local space."
      },
      {
        "name": "lookAt",
        "type": "(vector: Vector3) => void",
        "documentation": "Rotates object to face point in space."
      },
      {
        "name": "add",
        "type": "(...object: Object3D[]) => void",
        "documentation": "Adds object as child of this object."
      },
      {
        "name": "remove",
        "type": "(object: Object3D) => void",
        "documentation": "Removes object as child of this object."
      },
      {
        "name": "getObjectById",
        "type": "(id: number) => Object3D",
        "documentation": "Searches through the object's children and returns the first with a matching id, optionally recursive."
      },
      {
        "name": "getObjectByName",
        "type": "(name: string) => Object3D",
        "documentation": "Searches through the object's children and returns the first with a matching name, optionally recursive."
      },
      {
        "name": "getObjectByProperty",
        "type": "(name: string, value: string) => Object3D"
      },
      {
        "name": "getWorldPosition",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "getWorldQuaternion",
        "type": "(optionalTarget?: Quaternion) => Quaternion"
      },
      {
        "name": "getWorldRotation",
        "type": "(optionalTarget?: Euler) => Euler"
      },
      {
        "name": "getWorldScale",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "getWorldDirection",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      },
      {
        "name": "traverse",
        "type": "(callback: (object: Object3D) => any) => void"
      },
      {
        "name": "traverseVisible",
        "type": "(callback: (object: Object3D) => any) => void"
      },
      {
        "name": "traverseAncestors",
        "type": "(callback: (object: Object3D) => any) => void"
      },
      {
        "name": "updateMatrix",
        "type": "() => void",
        "documentation": "Updates local transform."
      },
      {
        "name": "updateMatrixWorld",
        "type": "(force: boolean) => void",
        "documentation": "Updates global transform of the object and its children."
      },
      {
        "name": "toJSON",
        "type": "(meta?: { geometries: any; materials: any; textures: any; images: any; }) => any"
      },
      {
        "name": "clone",
        "type": "(recursive?: boolean) => this"
      },
      {
        "name": "copy",
        "type": "(source: this, recursive?: boolean) => this"
      },
      {
        "name": "getChildByName",
        "type": "(name: string) => Object3D"
      },
      {
        "name": "translate",
        "type": "(distance: number, axis: Vector3) => Object3D"
      }
    ]
  },
  {
    "name": "Intersection",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "distanceToRay",
        "type": "number"
      },
      {
        "name": "point",
        "type": "Vector3"
      },
      {
        "name": "index",
        "type": "number"
      },
      {
        "name": "face",
        "type": "Face3"
      },
      {
        "name": "faceIndex",
        "type": "number"
      },
      {
        "name": "object",
        "type": "Object3D"
      }
    ],
    "methods": []
  },
  {
    "name": "RaycasterParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "Line?",
        "type": "any"
      },
      {
        "name": "LOD?",
        "type": "any"
      },
      {
        "name": "Sprite?",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "Points?",
        "type": "{ threshold: number; }"
      }
    ]
  },
  {
    "name": "Raycaster",
    "type": "typeof Raycaster",
    "constructors": [
      {
        "parameters": [
          {
            "name": "origin?",
            "type": "Vector3"
          },
          {
            "name": "direction?",
            "type": "Vector3"
          },
          {
            "name": "near?",
            "type": "number"
          },
          {
            "name": "far?",
            "type": "number"
          }
        ],
        "returnType": "Raycaster"
      }
    ],
    "properties": [
      {
        "name": "ray",
        "type": "Ray"
      },
      {
        "name": "near",
        "type": "number"
      },
      {
        "name": "far",
        "type": "number"
      },
      {
        "name": "params",
        "type": "RaycasterParameters"
      },
      {
        "name": "precision",
        "type": "number"
      },
      {
        "name": "linePrecision",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(origin: Vector3, direction: Vector3) => void"
      },
      {
        "name": "setFromCamera",
        "type": "(coords: { x: number; y: number; }, camera: Camera) => void"
      },
      {
        "name": "intersectObject",
        "type": "(object: Object3D, recursive?: boolean) => Intersection[]"
      },
      {
        "name": "intersectObjects",
        "type": "(objects: Object3D[], recursive?: boolean) => Intersection[]"
      }
    ]
  },
  {
    "name": "Layers",
    "type": "typeof Layers",
    "constructors": [
      {
        "returnType": "Layers"
      }
    ],
    "properties": [
      {
        "name": "mask",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(channel: number) => void"
      },
      {
        "name": "enable",
        "type": "(channel: number) => void"
      },
      {
        "name": "toggle",
        "type": "(channel: number) => void"
      },
      {
        "name": "disable",
        "type": "(channel: number) => void"
      },
      {
        "name": "test",
        "type": "(layers: Layers) => boolean"
      }
    ]
  },
  {
    "name": "Font",
    "type": "typeof Font",
    "constructors": [
      {
        "parameters": [
          {
            "name": "jsondata",
            "type": "string"
          }
        ],
        "returnType": "Font"
      }
    ],
    "properties": [
      {
        "name": "data",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "generateShapes",
        "type": "(text: string, size: number, divisions: number) => any[]"
      }
    ]
  },
  {
    "name": "Light",
    "type": "typeof Light",
    "documentation": "Abstract base class for lights.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex?",
            "type": "string | number"
          },
          {
            "name": "intensity?",
            "type": "number"
          }
        ],
        "returnType": "Light"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "intensity",
        "type": "number"
      },
      {
        "name": "receiveShadow",
        "type": "boolean"
      },
      {
        "name": "shadow",
        "type": "LightShadow"
      },
      {
        "name": "shadowCameraFov",
        "type": "any"
      },
      {
        "name": "shadowCameraLeft",
        "type": "any"
      },
      {
        "name": "shadowCameraRight",
        "type": "any"
      },
      {
        "name": "shadowCameraTop",
        "type": "any"
      },
      {
        "name": "shadowCameraBottom",
        "type": "any"
      },
      {
        "name": "shadowCameraNear",
        "type": "any"
      },
      {
        "name": "shadowCameraFar",
        "type": "any"
      },
      {
        "name": "shadowBias",
        "type": "any"
      },
      {
        "name": "shadowMapWidth",
        "type": "any"
      },
      {
        "name": "shadowMapHeight",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "LightShadow",
    "type": "typeof LightShadow",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "LightShadow"
      }
    ],
    "properties": [
      {
        "name": "camera",
        "type": "Camera"
      },
      {
        "name": "bias",
        "type": "number"
      },
      {
        "name": "radius",
        "type": "number"
      },
      {
        "name": "mapSize",
        "type": "Vector2"
      },
      {
        "name": "map",
        "type": "RenderTarget"
      },
      {
        "name": "matrix",
        "type": "Matrix4"
      }
    ],
    "methods": [
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "clone",
        "type": "(recursive?: boolean) => this"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "AmbientLight",
    "type": "typeof AmbientLight",
    "documentation": "This light's color gets applied to all the objects in the scene globally.\r\n\r\n# example\r\n     var light = new THREE.AmbientLight( 0x404040 ); // soft white light\r\n     scene.add( light );",
    "constructors": [
      {
        "documentation": "This creates a Ambientlight with a color.",
        "parameters": [
          {
            "name": "hex?",
            "type": "string | number",
            "documentation": "Numeric value of the RGB component of the color."
          },
          {
            "name": "intensity?",
            "type": "number"
          }
        ],
        "returnType": "AmbientLight"
      }
    ],
    "properties": [
      {
        "name": "castShadow",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "DirectionalLight",
    "type": "typeof DirectionalLight",
    "documentation": "Affects objects using MeshLambertMaterial or MeshPhongMaterial.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex?",
            "type": "string | number"
          },
          {
            "name": "intensity?",
            "type": "number"
          }
        ],
        "returnType": "DirectionalLight"
      }
    ],
    "properties": [
      {
        "name": "target",
        "type": "Object3D",
        "documentation": "Target used for shadow camera orientation."
      },
      {
        "name": "intensity",
        "type": "number",
        "documentation": "Light's intensity.\r\nDefault — 1.0."
      },
      {
        "name": "shadow",
        "type": "DirectionalLightShadow"
      }
    ],
    "methods": []
  },
  {
    "name": "DirectionalLightShadow",
    "type": "typeof DirectionalLightShadow",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "DirectionalLightShadow"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "HemisphereLight",
    "type": "typeof HemisphereLight",
    "constructors": [
      {
        "parameters": [
          {
            "name": "skyColorHex?",
            "type": "string | number"
          },
          {
            "name": "groundColorHex?",
            "type": "string | number"
          },
          {
            "name": "intensity?",
            "type": "number"
          }
        ],
        "returnType": "HemisphereLight"
      }
    ],
    "properties": [
      {
        "name": "groundColor",
        "type": "Color"
      },
      {
        "name": "intensity",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "PointLight",
    "type": "typeof PointLight",
    "documentation": "Affects objects using {@link MeshLambertMaterial} or {@link MeshPhongMaterial}.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex?",
            "type": "string | number"
          },
          {
            "name": "intensity?",
            "type": "number"
          },
          {
            "name": "distance?",
            "type": "number"
          },
          {
            "name": "decay?",
            "type": "number"
          }
        ],
        "returnType": "PointLight"
      }
    ],
    "properties": [
      {
        "name": "intensity",
        "type": "number"
      },
      {
        "name": "distance",
        "type": "number",
        "documentation": "If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.\r\nDefault — 0.0."
      },
      {
        "name": "decay",
        "type": "number"
      },
      {
        "name": "shadow",
        "type": "PointLightShadow"
      },
      {
        "name": "power",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "PointLightShadow",
    "type": "typeof PointLightShadow",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "PointLightShadow"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "SpotLight",
    "type": "typeof SpotLight",
    "documentation": "A point light that can cast shadow in one direction.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex?",
            "type": "string | number"
          },
          {
            "name": "intensity?",
            "type": "number"
          },
          {
            "name": "distance?",
            "type": "number"
          },
          {
            "name": "angle?",
            "type": "number"
          },
          {
            "name": "exponent?",
            "type": "number"
          },
          {
            "name": "decay?",
            "type": "number"
          }
        ],
        "returnType": "SpotLight"
      }
    ],
    "properties": [
      {
        "name": "target",
        "type": "Object3D",
        "documentation": "Spotlight focus points at target.position.\r\nDefault position — (0,0,0)."
      },
      {
        "name": "intensity",
        "type": "number",
        "documentation": "Light's intensity.\r\nDefault — 1.0."
      },
      {
        "name": "distance",
        "type": "number",
        "documentation": "If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.\r\nDefault — 0.0."
      },
      {
        "name": "angle",
        "type": "number"
      },
      {
        "name": "exponent",
        "type": "number",
        "documentation": "Rapidity of the falloff of light from its target direction.\r\nDefault — 10.0."
      },
      {
        "name": "decay",
        "type": "number"
      },
      {
        "name": "shadow",
        "type": "SpotLightShadow"
      },
      {
        "name": "power",
        "type": "number"
      },
      {
        "name": "penumbra",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "SpotLightShadow",
    "type": "typeof SpotLightShadow",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "SpotLightShadow"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Loader",
    "type": "typeof Loader",
    "documentation": "Base class for implementing loaders.\r\n\r\nEvents:\r\n     load\r\n         Dispatched when the image has completed loading\r\n         content — loaded image\r\n\r\n     error\r\n\r\n          Dispatched when the image can't be loaded\r\n          message — error message",
    "constructors": [
      {
        "returnType": "Loader"
      }
    ],
    "properties": [
      {
        "name": "crossOrigin",
        "type": "string",
        "documentation": "default — null.\r\nIf set, assigns the crossOrigin attribute of the image to the value of crossOrigin, prior to starting the load."
      }
    ],
    "methods": [
      {
        "name": "onLoadStart",
        "type": "() => void",
        "documentation": "Will be called when load starts.\r\nThe default is a function with empty body."
      },
      {
        "name": "onLoadProgress",
        "type": "() => void",
        "documentation": "Will be called while load progresses.\r\nThe default is a function with empty body."
      },
      {
        "name": "onLoadComplete",
        "type": "() => void",
        "documentation": "Will be called when load completes.\r\nThe default is a function with empty body."
      },
      {
        "name": "extractUrlBase",
        "type": "(url: string) => string"
      },
      {
        "name": "initMaterials",
        "type": "(materials: Material[], texturePath: string) => Material[]"
      },
      {
        "name": "createMaterial",
        "type": "(m: Material, texturePath: string, crossOrigin?: string) => boolean"
      }
    ]
  },
  {
    "name": "AnyLoader",
    "type": "any",
    "documentation": "Interface for all loaders\r\nCompressedTextureLoader don't extends Loader class, but have load method",
    "constructors": [],
    "properties": [],
    "methods": []
  },
  {
    "name": "LoaderHandler",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "add",
        "type": "(regex: RegExp, loader: AnyLoader) => void"
      },
      {
        "name": "get",
        "type": "(file: string) => AnyLoader"
      }
    ]
  },
  {
    "name": "FileLoader",
    "type": "typeof FileLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "FileLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "mimeType",
        "type": "MimeType"
      },
      {
        "name": "path",
        "type": "string"
      },
      {
        "name": "responseType",
        "type": "string"
      },
      {
        "name": "withCredentials",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (responseText: string) => void, onProgress?: (request: ProgressEvent) => v..."
      },
      {
        "name": "setMimeType",
        "type": "(mimeType: MimeType) => FileLoader"
      },
      {
        "name": "setPath",
        "type": "(path: string) => FileLoader"
      },
      {
        "name": "setResponseType",
        "type": "(responseType: string) => FileLoader"
      },
      {
        "name": "setWithCredentials",
        "type": "(value: string) => FileLoader"
      }
    ]
  },
  {
    "name": "FontLoader",
    "type": "typeof FontLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "FontLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (responseFont: Font) => void, onProgress?: (event: ProgressEvent) => void,..."
      },
      {
        "name": "parse",
        "type": "(json: string) => Font"
      }
    ]
  },
  {
    "name": "ImageLoader",
    "type": "typeof ImageLoader",
    "documentation": "A loader for loading an image.\r\nUnlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "ImageLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "crossOrigin",
        "type": "string"
      },
      {
        "name": "withCredentials",
        "type": "string"
      },
      {
        "name": "path",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (image: HTMLImageElement) => void, onProgress?: (event: ProgressEvent) => ...",
        "documentation": "Begin loading from url"
      },
      {
        "name": "setCrossOrigin",
        "type": "(crossOrigin: string) => ImageLoader"
      },
      {
        "name": "setWithCredentials",
        "type": "(value: string) => ImageLoader"
      },
      {
        "name": "setPath",
        "type": "(value: string) => ImageLoader"
      }
    ]
  },
  {
    "name": "JSONLoader",
    "type": "typeof JSONLoader",
    "documentation": "A loader for loading objects in JSON format.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "JSONLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "withCredentials",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (geometry: Geometry, materials: Material[]) => void, onProgress?: (event: ..."
      },
      {
        "name": "setTexturePath",
        "type": "(value: string) => void"
      },
      {
        "name": "parse",
        "type": "(json: any, texturePath?: string) => { geometry: Geometry; materials?: Material[]; }"
      }
    ]
  },
  {
    "name": "LoadingManager",
    "type": "typeof LoadingManager",
    "documentation": "Handles and keeps track of loaded and pending data.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "onLoad?",
            "type": "() => void"
          },
          {
            "name": "onProgress?",
            "type": "(url: string, loaded: number, total: number) => void"
          },
          {
            "name": "onError?",
            "type": "() => void"
          }
        ],
        "returnType": "LoadingManager"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "onStart",
        "type": "() => void"
      },
      {
        "name": "onLoad",
        "type": "() => void",
        "documentation": "Will be called when load starts.\r\nThe default is a function with empty body."
      },
      {
        "name": "onProgress",
        "type": "(item: any, loaded: number, total: number) => void",
        "documentation": "Will be called while load progresses.\r\nThe default is a function with empty body."
      },
      {
        "name": "onError",
        "type": "() => void",
        "documentation": "Will be called when each element in the scene completes loading.\r\nThe default is a function with empty body."
      },
      {
        "name": "itemStart",
        "type": "(url: string) => void"
      },
      {
        "name": "itemEnd",
        "type": "(url: string) => void"
      },
      {
        "name": "itemError",
        "type": "(url: string) => void"
      }
    ]
  },
  {
    "name": "BufferGeometryLoader",
    "type": "typeof BufferGeometryLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "BufferGeometryLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: (bufferGeometry: BufferGeometry) => void, onProgress?: (event: any) => void..."
      },
      {
        "name": "parse",
        "type": "(json: any) => BufferGeometry"
      }
    ]
  },
  {
    "name": "MaterialLoader",
    "type": "typeof MaterialLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "MaterialLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      }
    ],
    "methods": [
      {
        "name": "textures",
        "type": "{ [key: string]: Texture; }"
      },
      {
        "name": "load",
        "type": "(url: string, onLoad: (material: Material) => void) => void"
      },
      {
        "name": "setTextures",
        "type": "(textures: { [key: string]: Texture; }) => void"
      },
      {
        "name": "getTexture",
        "type": "(name: string) => Texture"
      },
      {
        "name": "parse",
        "type": "(json: any) => Material"
      }
    ]
  },
  {
    "name": "ObjectLoader",
    "type": "typeof ObjectLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "ObjectLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "texturePass",
        "type": "string"
      },
      {
        "name": "crossOrigin",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (object: Object3D) => void, onProgress?: (event: ProgressEvent) => void, o..."
      },
      {
        "name": "setTexturePath",
        "type": "(value: string) => void"
      },
      {
        "name": "setCrossOrigin",
        "type": "(crossOrigin: string) => void"
      },
      {
        "name": "parse",
        "type": "<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void) => T"
      },
      {
        "name": "parseGeometries",
        "type": "(json: any) => any[]"
      },
      {
        "name": "parseMaterials",
        "type": "(json: any, textures: Texture[]) => Material[]"
      },
      {
        "name": "parseAnimations",
        "type": "(json: any) => AnimationClip[]"
      },
      {
        "name": "parseImages",
        "type": "(json: any, onLoad: () => void) => { [key: string]: HTMLImageElement; }"
      },
      {
        "name": "parseTextures",
        "type": "(json: any, images: any) => Texture[]"
      },
      {
        "name": "parseObject",
        "type": "<T extends Object3D>(data: any, geometries: any[], materials: Material[]) => T"
      }
    ]
  },
  {
    "name": "TextureLoader",
    "type": "typeof TextureLoader",
    "documentation": "Class for loading a texture.\r\nUnlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "TextureLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "crossOrigin",
        "type": "string"
      },
      {
        "name": "withCredentials",
        "type": "string"
      },
      {
        "name": "path",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad?: (texture: Texture) => void, onProgress?: (event: ProgressEvent) => void, o...",
        "documentation": "Begin loading from url"
      },
      {
        "name": "setCrossOrigin",
        "type": "(crossOrigin: string) => TextureLoader"
      },
      {
        "name": "setWithCredentials",
        "type": "(value: string) => TextureLoader"
      },
      {
        "name": "setPath",
        "type": "(path: string) => TextureLoader"
      }
    ]
  },
  {
    "name": "CubeTextureLoader",
    "type": "typeof CubeTextureLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "CubeTextureLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "corssOrigin",
        "type": "string"
      },
      {
        "name": "path",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(urls: string[], onLoad?: (texture: CubeTexture) => void, onProgress?: (event: ProgressEvent) => ..."
      },
      {
        "name": "setCrossOrigin",
        "type": "(crossOrigin: string) => CubeTextureLoader"
      },
      {
        "name": "setPath",
        "type": "(path: string) => CubeTextureLoader"
      }
    ]
  },
  {
    "name": "DataTextureLoader",
    "type": "typeof DataTextureLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "DataTextureLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: (dataTexture: DataTexture) => void, onProgress?: (event: ProgressEvent) => ..."
      }
    ]
  },
  {
    "name": "BinaryTextureLoader",
    "type": "typeof BinaryTextureLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "BinaryTextureLoader"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "CompressedTextureLoader",
    "type": "typeof CompressedTextureLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "CompressedTextureLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "path",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: (texture: CompressedTexture) => void, onProgress?: (event: ProgressEvent) =..."
      },
      {
        "name": "setPath",
        "type": "(path: string) => CompressedTextureLoader"
      }
    ]
  },
  {
    "name": "AudioLoader",
    "type": "typeof AudioLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "AudioLoader"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: Function, onPrgress: Function, onError: Function) => void"
      }
    ]
  },
  {
    "name": "MaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "blendDst?",
        "type": "BlendingDstFactor"
      },
      {
        "name": "blendDstAlpha?",
        "type": "number"
      },
      {
        "name": "blendEquation?",
        "type": "BlendingEquation"
      },
      {
        "name": "blendEquationAlpha?",
        "type": "number"
      },
      {
        "name": "blending?",
        "type": "Blending"
      },
      {
        "name": "blendSrcAlpha?",
        "type": "number"
      },
      {
        "name": "clipIntersection?",
        "type": "boolean"
      },
      {
        "name": "clipShadows?",
        "type": "boolean"
      },
      {
        "name": "colorWrite?",
        "type": "boolean"
      },
      {
        "name": "depthFunc?",
        "type": "DepthModes"
      },
      {
        "name": "depthTest?",
        "type": "boolean"
      },
      {
        "name": "depthWrite?",
        "type": "boolean"
      },
      {
        "name": "fog?",
        "type": "boolean"
      },
      {
        "name": "lights?",
        "type": "boolean"
      },
      {
        "name": "name?",
        "type": "string"
      },
      {
        "name": "opacity?",
        "type": "number"
      },
      {
        "name": "overdraw?",
        "type": "number"
      },
      {
        "name": "polygonOffset?",
        "type": "boolean"
      },
      {
        "name": "polygonOffsetFactor?",
        "type": "number"
      },
      {
        "name": "polygonOffsetUnits?",
        "type": "number"
      },
      {
        "name": "premultipliedAlpha?",
        "type": "boolean"
      },
      {
        "name": "dithering?",
        "type": "boolean"
      },
      {
        "name": "flatShading?",
        "type": "boolean"
      },
      {
        "name": "side?",
        "type": "Side"
      },
      {
        "name": "transparent?",
        "type": "boolean"
      },
      {
        "name": "vertexColors?",
        "type": "Colors"
      },
      {
        "name": "visible?",
        "type": "boolean"
      },
      {
        "name": "shading?",
        "type": "Shading"
      }
    ],
    "methods": [
      {
        "name": "blendSrc?",
        "type": "BlendingDstFactor | BlendingSrcFactor"
      },
      {
        "name": "clippingPlanes?",
        "type": "Plane[]"
      },
      {
        "name": "precision?",
        "type": "\"highp\" | \"mediump\" | \"lowp\""
      }
    ]
  },
  {
    "name": "Material",
    "type": "typeof Material",
    "documentation": "Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.",
    "constructors": [
      {
        "returnType": "Material"
      }
    ],
    "properties": [
      {
        "name": "alphaTest",
        "type": "number",
        "documentation": "Sets the alpha value to be used when running an alpha test. Default is 0."
      },
      {
        "name": "blendDst",
        "type": "BlendingDstFactor",
        "documentation": "Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}."
      },
      {
        "name": "blendDstAlpha",
        "type": "number",
        "documentation": "The tranparency of the .blendDst. Default is null."
      },
      {
        "name": "blendEquation",
        "type": "BlendingEquation",
        "documentation": "Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}."
      },
      {
        "name": "blendEquationAlpha",
        "type": "number",
        "documentation": "The tranparency of the .blendEquation. Default is null."
      },
      {
        "name": "blending",
        "type": "Blending",
        "documentation": "Which blending to use when displaying objects with this material. Default is {@link NormalBlending}."
      },
      {
        "name": "blendSrcAlpha",
        "type": "number",
        "documentation": "The tranparency of the .blendSrc. Default is null."
      },
      {
        "name": "clipIntersection",
        "type": "boolean",
        "documentation": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false."
      },
      {
        "name": "clippingPlanes",
        "type": "any",
        "documentation": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). See the WebGL / clipping /intersection example. Default is null."
      },
      {
        "name": "clipShadows",
        "type": "boolean",
        "documentation": "Defines whether to clip shadows according to the clipping planes specified on this material. Default is false."
      },
      {
        "name": "colorWrite",
        "type": "boolean",
        "documentation": "Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true."
      },
      {
        "name": "depthFunc",
        "type": "DepthModes",
        "documentation": "Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values."
      },
      {
        "name": "depthTest",
        "type": "boolean",
        "documentation": "Whether to have depth test enabled when rendering this material. Default is true."
      },
      {
        "name": "depthWrite",
        "type": "boolean",
        "documentation": "Whether rendering this material has any effect on the depth buffer. Default is true.\r\nWhen drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
      },
      {
        "name": "fog",
        "type": "boolean",
        "documentation": "Whether the material is affected by fog. Default is true."
      },
      {
        "name": "id",
        "type": "number",
        "documentation": "Unique number of this material instance."
      },
      {
        "name": "isMaterial",
        "type": "boolean",
        "documentation": "Used to check whether this or derived classes are materials. Default is true.\r\nYou should not change this, as it used internally for optimisation."
      },
      {
        "name": "lights",
        "type": "boolean",
        "documentation": "Whether the material is affected by lights. Default is true."
      },
      {
        "name": "name",
        "type": "string",
        "documentation": "Material name. Default is an empty string."
      },
      {
        "name": "needsUpdate",
        "type": "boolean",
        "documentation": "Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.\r\nThis property is automatically set to true when instancing a new material."
      },
      {
        "name": "opacity",
        "type": "number",
        "documentation": "Opacity. Default is 1."
      },
      {
        "name": "overdraw",
        "type": "number",
        "documentation": "Enables/disables overdraw. If greater than zero, polygons are drawn slightly bigger in order to fix antialiasing gaps when using the CanvasRenderer. Default is 0."
      },
      {
        "name": "polygonOffset",
        "type": "boolean",
        "documentation": "Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature."
      },
      {
        "name": "polygonOffsetFactor",
        "type": "number",
        "documentation": "Sets the polygon offset factor. Default is 0."
      },
      {
        "name": "polygonOffsetUnits",
        "type": "number",
        "documentation": "Sets the polygon offset units. Default is 0."
      },
      {
        "name": "premultipliedAlpha",
        "type": "boolean",
        "documentation": "Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false."
      },
      {
        "name": "dithering",
        "type": "boolean",
        "documentation": "Whether to apply dithering to the color to remove the appearance of banding. Default is false."
      },
      {
        "name": "flatShading",
        "type": "boolean",
        "documentation": "Define whether the material is rendered with flat shading. Default is false."
      },
      {
        "name": "side",
        "type": "Side",
        "documentation": "Defines which of the face sides will be rendered - front, back or both.\r\nDefault is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide."
      },
      {
        "name": "transparent",
        "type": "boolean",
        "documentation": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.\r\nWhen set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.\r\nDefault is false."
      },
      {
        "name": "type",
        "type": "string",
        "documentation": "Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene."
      },
      {
        "name": "uuid",
        "type": "string",
        "documentation": "UUID of this material instance. This gets automatically assigned, so this shouldn't be edited."
      },
      {
        "name": "vertexColors",
        "type": "Colors",
        "documentation": "Defines whether vertex coloring is used. Default is THREE.NoColors. Other options are THREE.VertexColors and THREE.FaceColors."
      },
      {
        "name": "visible",
        "type": "boolean",
        "documentation": "Defines whether this material is visible. Default is true."
      },
      {
        "name": "userData",
        "type": "any",
        "documentation": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
      },
      {
        "name": "warpRGB",
        "type": "Color"
      },
      {
        "name": "shading",
        "type": "Shading"
      }
    ],
    "methods": [
      {
        "name": "blendSrc",
        "type": "BlendingDstFactor | BlendingSrcFactor",
        "documentation": "Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}."
      },
      {
        "name": "precision",
        "type": "\"highp\" | \"mediump\" | \"lowp\"",
        "documentation": "Override the renderer's default precision for this material. Can be \"highp\", \"mediump\" or \"lowp\". Defaults is null."
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Return a new material with the same parameters as this material."
      },
      {
        "name": "copy",
        "type": "(material: this) => this",
        "documentation": "Copy the parameters from the passed material into this material."
      },
      {
        "name": "dispose",
        "type": "() => void",
        "documentation": "This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}."
      },
      {
        "name": "setValues",
        "type": "(values: MaterialParameters) => void",
        "documentation": "Sets the properties based on the values."
      },
      {
        "name": "toJSON",
        "type": "(meta?: any) => any",
        "documentation": "Convert the material to three.js JSON format."
      },
      {
        "name": "update",
        "type": "() => void",
        "documentation": "Call .dispatchEvent ( { type: 'update' }) on the material."
      }
    ]
  },
  {
    "name": "LineBasicMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "linewidth?",
        "type": "number"
      },
      {
        "name": "linecap?",
        "type": "string"
      },
      {
        "name": "linejoin?",
        "type": "string"
      }
    ],
    "methods": []
  },
  {
    "name": "LineBasicMaterial",
    "type": "typeof LineBasicMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "LineBasicMaterialParameters"
          }
        ],
        "returnType": "LineBasicMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "linewidth",
        "type": "number"
      },
      {
        "name": "linecap",
        "type": "string"
      },
      {
        "name": "linejoin",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: LineBasicMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "LineDashedMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "linewidth?",
        "type": "number"
      },
      {
        "name": "scale?",
        "type": "number"
      },
      {
        "name": "dashSize?",
        "type": "number"
      },
      {
        "name": "gapSize?",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "LineDashedMaterial",
    "type": "typeof LineDashedMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "LineDashedMaterialParameters"
          }
        ],
        "returnType": "LineDashedMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "linewidth",
        "type": "number"
      },
      {
        "name": "scale",
        "type": "number"
      },
      {
        "name": "dashSize",
        "type": "number"
      },
      {
        "name": "gapSize",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: LineDashedMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshBasicMaterialParameters",
    "type": "any",
    "documentation": "parameters is an object with one or more properties defining the material's appearance.",
    "constructors": [],
    "properties": [
      {
        "name": "opacity?",
        "type": "number"
      },
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "aoMap?",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity?",
        "type": "number"
      },
      {
        "name": "specularMap?",
        "type": "Texture"
      },
      {
        "name": "alphaMap?",
        "type": "Texture"
      },
      {
        "name": "envMap?",
        "type": "Texture"
      },
      {
        "name": "combine?",
        "type": "Combine"
      },
      {
        "name": "reflectivity?",
        "type": "number"
      },
      {
        "name": "refractionRatio?",
        "type": "number"
      },
      {
        "name": "shading?",
        "type": "Shading"
      },
      {
        "name": "wireframe?",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      },
      {
        "name": "wireframeLinecap?",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin?",
        "type": "string"
      },
      {
        "name": "skinning?",
        "type": "boolean"
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshBasicMaterial",
    "type": "typeof MeshBasicMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshBasicMaterialParameters"
          }
        ],
        "returnType": "MeshBasicMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "aoMap",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity",
        "type": "number"
      },
      {
        "name": "specularMap",
        "type": "Texture"
      },
      {
        "name": "alphaMap",
        "type": "Texture"
      },
      {
        "name": "envMap",
        "type": "Texture"
      },
      {
        "name": "combine",
        "type": "Combine"
      },
      {
        "name": "reflectivity",
        "type": "number"
      },
      {
        "name": "refractionRatio",
        "type": "number"
      },
      {
        "name": "shading",
        "type": "Shading"
      },
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "wireframeLinecap",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin",
        "type": "string"
      },
      {
        "name": "skinning",
        "type": "boolean"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshBasicMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshDepthMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshDepthMaterial",
    "type": "typeof MeshDepthMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshDepthMaterialParameters"
          }
        ],
        "returnType": "MeshDepthMaterial"
      }
    ],
    "properties": [
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshDepthMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshLambertMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "emissiveIntensity?",
        "type": "number"
      },
      {
        "name": "emissiveMap?",
        "type": "Texture"
      },
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "lightMap?",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity?",
        "type": "number"
      },
      {
        "name": "aoMap?",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity?",
        "type": "number"
      },
      {
        "name": "specularMap?",
        "type": "Texture"
      },
      {
        "name": "alphaMap?",
        "type": "Texture"
      },
      {
        "name": "envMap?",
        "type": "Texture"
      },
      {
        "name": "combine?",
        "type": "Combine"
      },
      {
        "name": "reflectivity?",
        "type": "number"
      },
      {
        "name": "refractionRatio?",
        "type": "number"
      },
      {
        "name": "wireframe?",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      },
      {
        "name": "wireframeLinecap?",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin?",
        "type": "string"
      },
      {
        "name": "skinning?",
        "type": "boolean"
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      },
      {
        "name": "morphNormals?",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "emissive?",
        "type": "string | number"
      }
    ]
  },
  {
    "name": "MeshLambertMaterial",
    "type": "typeof MeshLambertMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshLambertMaterialParameters"
          }
        ],
        "returnType": "MeshLambertMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "emissive",
        "type": "Color"
      },
      {
        "name": "emissiveIntensity",
        "type": "number"
      },
      {
        "name": "emissiveMap",
        "type": "Texture"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "lightMap",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity",
        "type": "number"
      },
      {
        "name": "aoMap",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity",
        "type": "number"
      },
      {
        "name": "specularMap",
        "type": "Texture"
      },
      {
        "name": "alphaMap",
        "type": "Texture"
      },
      {
        "name": "envMap",
        "type": "Texture"
      },
      {
        "name": "combine",
        "type": "Combine"
      },
      {
        "name": "reflectivity",
        "type": "number"
      },
      {
        "name": "refractionRatio",
        "type": "number"
      },
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "wireframeLinecap",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin",
        "type": "string"
      },
      {
        "name": "skinning",
        "type": "boolean"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      },
      {
        "name": "morphNormals",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshLambertMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshStandardMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "roughness?",
        "type": "number"
      },
      {
        "name": "metalness?",
        "type": "number"
      },
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "lightMap?",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity?",
        "type": "number"
      },
      {
        "name": "aoMap?",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity?",
        "type": "number"
      },
      {
        "name": "emissive?",
        "type": "Color"
      },
      {
        "name": "emissiveIntensity?",
        "type": "number"
      },
      {
        "name": "emissiveMap?",
        "type": "Texture"
      },
      {
        "name": "bumpMap?",
        "type": "Texture"
      },
      {
        "name": "bumpScale?",
        "type": "number"
      },
      {
        "name": "normalMap?",
        "type": "Texture"
      },
      {
        "name": "normalScale?",
        "type": "Vector2"
      },
      {
        "name": "displacementMap?",
        "type": "Texture"
      },
      {
        "name": "displacementScale?",
        "type": "number"
      },
      {
        "name": "displacementBias?",
        "type": "number"
      },
      {
        "name": "roughnessMap?",
        "type": "Texture"
      },
      {
        "name": "metalnessMap?",
        "type": "Texture"
      },
      {
        "name": "alphaMap?",
        "type": "Texture"
      },
      {
        "name": "envMap?",
        "type": "Texture"
      },
      {
        "name": "envMapIntensity?",
        "type": "number"
      },
      {
        "name": "refractionRatio?",
        "type": "number"
      },
      {
        "name": "wireframe?",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      },
      {
        "name": "skinning?",
        "type": "boolean"
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      },
      {
        "name": "morphNormals?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshStandardMaterial",
    "type": "typeof MeshStandardMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshStandardMaterialParameters"
          }
        ],
        "returnType": "MeshStandardMaterial"
      }
    ],
    "properties": [
      {
        "name": "defines",
        "type": "any"
      },
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "roughness",
        "type": "number"
      },
      {
        "name": "metalness",
        "type": "number"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "lightMap",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity",
        "type": "number"
      },
      {
        "name": "aoMap",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity",
        "type": "number"
      },
      {
        "name": "emissive",
        "type": "Color"
      },
      {
        "name": "emissiveIntensity",
        "type": "number"
      },
      {
        "name": "emissiveMap",
        "type": "Texture"
      },
      {
        "name": "bumpMap",
        "type": "Texture"
      },
      {
        "name": "bumpScale",
        "type": "number"
      },
      {
        "name": "normalMap",
        "type": "Texture"
      },
      {
        "name": "normalScale",
        "type": "number"
      },
      {
        "name": "displacementMap",
        "type": "Texture"
      },
      {
        "name": "displacementScale",
        "type": "number"
      },
      {
        "name": "displacementBias",
        "type": "number"
      },
      {
        "name": "roughnessMap",
        "type": "Texture"
      },
      {
        "name": "metalnessMap",
        "type": "Texture"
      },
      {
        "name": "alphaMap",
        "type": "Texture"
      },
      {
        "name": "envMap",
        "type": "Texture"
      },
      {
        "name": "envMapIntensity",
        "type": "number"
      },
      {
        "name": "refractionRatio",
        "type": "number"
      },
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "skinning",
        "type": "boolean"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      },
      {
        "name": "morphNormals",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshStandardMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshNormalMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "wireframeLinewidth?",
        "type": "number",
        "documentation": "Controls wireframe thickness. Default is 1. "
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshNormalMaterial",
    "type": "typeof MeshNormalMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshNormalMaterialParameters"
          }
        ],
        "returnType": "MeshNormalMaterial"
      }
    ],
    "properties": [
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshNormalMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshPhongMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "specular?",
        "type": "number"
      },
      {
        "name": "shininess?",
        "type": "number"
      },
      {
        "name": "opacity?",
        "type": "number"
      },
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "lightMap?",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity?",
        "type": "number"
      },
      {
        "name": "aoMap?",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity?",
        "type": "number"
      },
      {
        "name": "emissive?",
        "type": "number"
      },
      {
        "name": "emissiveIntensity?",
        "type": "number"
      },
      {
        "name": "emissiveMap?",
        "type": "Texture"
      },
      {
        "name": "bumpMap?",
        "type": "Texture"
      },
      {
        "name": "bumpScale?",
        "type": "number"
      },
      {
        "name": "normalMap?",
        "type": "Texture"
      },
      {
        "name": "normalScale?",
        "type": "Vector2"
      },
      {
        "name": "displacementMap?",
        "type": "Texture"
      },
      {
        "name": "displacementScale?",
        "type": "number"
      },
      {
        "name": "displacementBias?",
        "type": "number"
      },
      {
        "name": "specularMap?",
        "type": "Texture"
      },
      {
        "name": "alphaMap?",
        "type": "Texture"
      },
      {
        "name": "envMap?",
        "type": "Texture"
      },
      {
        "name": "combine?",
        "type": "Combine"
      },
      {
        "name": "reflectivity?",
        "type": "number"
      },
      {
        "name": "refractionRatio?",
        "type": "number"
      },
      {
        "name": "wireframe?",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      },
      {
        "name": "wireframeLinecap?",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin?",
        "type": "string"
      },
      {
        "name": "skinning?",
        "type": "boolean"
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      },
      {
        "name": "morphNormals?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshPhongMaterial",
    "type": "typeof MeshPhongMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "MeshPhongMaterialParameters"
          }
        ],
        "returnType": "MeshPhongMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "specular",
        "type": "Color"
      },
      {
        "name": "shininess",
        "type": "number"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "lightMap",
        "type": "Texture"
      },
      {
        "name": "lightMapIntensity",
        "type": "number"
      },
      {
        "name": "aoMap",
        "type": "Texture"
      },
      {
        "name": "aoMapIntensity",
        "type": "number"
      },
      {
        "name": "emissive",
        "type": "Color"
      },
      {
        "name": "emissiveIntensity",
        "type": "number"
      },
      {
        "name": "emissiveMap",
        "type": "Texture"
      },
      {
        "name": "bumpMap",
        "type": "Texture"
      },
      {
        "name": "bumpScale",
        "type": "number"
      },
      {
        "name": "normalMap",
        "type": "Texture"
      },
      {
        "name": "normalScale",
        "type": "Vector2"
      },
      {
        "name": "displacementMap",
        "type": "Texture"
      },
      {
        "name": "displacementScale",
        "type": "number"
      },
      {
        "name": "displacementBias",
        "type": "number"
      },
      {
        "name": "specularMap",
        "type": "Texture"
      },
      {
        "name": "alphaMap",
        "type": "Texture"
      },
      {
        "name": "envMap",
        "type": "Texture"
      },
      {
        "name": "combine",
        "type": "Combine"
      },
      {
        "name": "reflectivity",
        "type": "number"
      },
      {
        "name": "refractionRatio",
        "type": "number"
      },
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "wireframeLinecap",
        "type": "string"
      },
      {
        "name": "wireframeLinejoin",
        "type": "string"
      },
      {
        "name": "skinning",
        "type": "boolean"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      },
      {
        "name": "morphNormals",
        "type": "boolean"
      },
      {
        "name": "metal",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: MeshPhongMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "MeshPhysicalMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "clearCoat?",
        "type": "number"
      },
      {
        "name": "clearCoatRoughness?",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "MeshPhysicalMaterial",
    "type": "typeof MeshPhysicalMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters",
            "type": "MeshPhysicalMaterialParameters"
          }
        ],
        "returnType": "MeshPhysicalMaterial"
      }
    ],
    "properties": [
      {
        "name": "defines",
        "type": "any"
      },
      {
        "name": "reflectivity",
        "type": "number"
      },
      {
        "name": "clearCoat",
        "type": "number"
      },
      {
        "name": "clearCoatRoughness",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "MultiMaterial",
    "type": "typeof MultiMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "materials?",
            "type": "Material[]"
          }
        ],
        "returnType": "MultiMaterial"
      }
    ],
    "properties": [
      {
        "name": "isMultiMaterial",
        "type": "true"
      }
    ],
    "methods": [
      {
        "name": "materials",
        "type": "Material[]"
      },
      {
        "name": "toJSON",
        "type": "(meta: any) => any"
      }
    ]
  },
  {
    "name": "MeshFaceMaterial",
    "type": "typeof MeshFaceMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "materials?",
            "type": "Material[]"
          }
        ],
        "returnType": "MeshFaceMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "PointsMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "size?",
        "type": "number"
      },
      {
        "name": "sizeAttenuation?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "PointsMaterial",
    "type": "typeof PointsMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "PointsMaterialParameters"
          }
        ],
        "returnType": "PointsMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "size",
        "type": "number"
      },
      {
        "name": "sizeAttenuation",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: PointsMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "PointCloudMaterial",
    "type": "typeof PointCloudMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "PointsMaterialParameters"
          }
        ],
        "returnType": "PointCloudMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ParticleBasicMaterial",
    "type": "typeof ParticleBasicMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "PointsMaterialParameters"
          }
        ],
        "returnType": "ParticleBasicMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ParticleSystemMaterial",
    "type": "typeof ParticleSystemMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "PointsMaterialParameters"
          }
        ],
        "returnType": "ParticleSystemMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ShaderMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "uniforms?",
        "type": "any"
      },
      {
        "name": "vertexShader?",
        "type": "string"
      },
      {
        "name": "fragmentShader?",
        "type": "string"
      },
      {
        "name": "lineWidth?",
        "type": "number"
      },
      {
        "name": "wireframe?",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth?",
        "type": "number"
      },
      {
        "name": "lights?",
        "type": "boolean"
      },
      {
        "name": "clipping?",
        "type": "boolean"
      },
      {
        "name": "skinning?",
        "type": "boolean"
      },
      {
        "name": "morphTargets?",
        "type": "boolean"
      },
      {
        "name": "morphNormals?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "ShaderMaterial",
    "type": "typeof ShaderMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "ShaderMaterialParameters"
          }
        ],
        "returnType": "ShaderMaterial"
      }
    ],
    "properties": [
      {
        "name": "defines",
        "type": "any"
      },
      {
        "name": "vertexShader",
        "type": "string"
      },
      {
        "name": "fragmentShader",
        "type": "string"
      },
      {
        "name": "linewidth",
        "type": "number"
      },
      {
        "name": "wireframe",
        "type": "boolean"
      },
      {
        "name": "wireframeLinewidth",
        "type": "number"
      },
      {
        "name": "lights",
        "type": "boolean"
      },
      {
        "name": "clipping",
        "type": "boolean"
      },
      {
        "name": "skinning",
        "type": "boolean"
      },
      {
        "name": "morphTargets",
        "type": "boolean"
      },
      {
        "name": "morphNormals",
        "type": "boolean"
      },
      {
        "name": "derivatives",
        "type": "any"
      },
      {
        "name": "defaultAttributeValues",
        "type": "any"
      },
      {
        "name": "index0AttributeName",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "uniforms",
        "type": "{ [uniform: string]: IUniform; }"
      },
      {
        "name": "extensions",
        "type": "{ derivatives: boolean; fragDepth: boolean; drawBuffers: boolean; shaderTextureLOD: boolean; }"
      },
      {
        "name": "setValues",
        "type": "(parameters: ShaderMaterialParameters) => void"
      },
      {
        "name": "toJSON",
        "type": "(meta: any) => any"
      }
    ]
  },
  {
    "name": "RawShaderMaterial",
    "type": "typeof RawShaderMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "ShaderMaterialParameters"
          }
        ],
        "returnType": "RawShaderMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "SpriteMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "map?",
        "type": "Texture"
      },
      {
        "name": "rotation?",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "SpriteMaterial",
    "type": "typeof SpriteMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "SpriteMaterialParameters"
          }
        ],
        "returnType": "SpriteMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "map",
        "type": "Texture"
      },
      {
        "name": "rotation",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "setValues",
        "type": "(parameters: SpriteMaterialParameters) => void"
      }
    ]
  },
  {
    "name": "ShadowMaterial",
    "type": "typeof ShadowMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "ShaderMaterialParameters"
          }
        ],
        "returnType": "ShadowMaterial"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Box2",
    "type": "typeof Box2",
    "constructors": [
      {
        "parameters": [
          {
            "name": "min?",
            "type": "Vector2"
          },
          {
            "name": "max?",
            "type": "Vector2"
          }
        ],
        "returnType": "Box2"
      }
    ],
    "properties": [
      {
        "name": "max",
        "type": "Vector2"
      },
      {
        "name": "min",
        "type": "Vector2"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(min: Vector2, max: Vector2) => Box2"
      },
      {
        "name": "setFromPoints",
        "type": "(points: Vector2[]) => Box2"
      },
      {
        "name": "setFromCenterAndSize",
        "type": "(center: Vector2, size: Vector2) => Box2"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(box: this) => this"
      },
      {
        "name": "makeEmpty",
        "type": "() => Box2"
      },
      {
        "name": "isEmpty",
        "type": "() => boolean"
      },
      {
        "name": "getCenter",
        "type": "(optionalTarget?: Vector2) => Vector2"
      },
      {
        "name": "getSize",
        "type": "(optionalTarget?: Vector2) => Vector2"
      },
      {
        "name": "expandByPoint",
        "type": "(point: Vector2) => Box2"
      },
      {
        "name": "expandByVector",
        "type": "(vector: Vector2) => Box2"
      },
      {
        "name": "expandByScalar",
        "type": "(scalar: number) => Box2"
      },
      {
        "name": "containsPoint",
        "type": "(point: Vector2) => boolean"
      },
      {
        "name": "containsBox",
        "type": "(box: Box2) => boolean"
      },
      {
        "name": "getParameter",
        "type": "(point: Vector2) => Vector2"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box2) => boolean"
      },
      {
        "name": "clampPoint",
        "type": "(point: Vector2, optionalTarget?: Vector2) => Vector2"
      },
      {
        "name": "distanceToPoint",
        "type": "(point: Vector2) => number"
      },
      {
        "name": "intersect",
        "type": "(box: Box2) => Box2"
      },
      {
        "name": "union",
        "type": "(box: Box2) => Box2"
      },
      {
        "name": "translate",
        "type": "(offset: Vector2) => Box2"
      },
      {
        "name": "equals",
        "type": "(box: Box2) => boolean"
      },
      {
        "name": "empty",
        "type": "() => any"
      },
      {
        "name": "isIntersectionBox",
        "type": "(b: any) => any"
      }
    ]
  },
  {
    "name": "Box3",
    "type": "typeof Box3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "min?",
            "type": "Vector3"
          },
          {
            "name": "max?",
            "type": "Vector3"
          }
        ],
        "returnType": "Box3"
      }
    ],
    "properties": [
      {
        "name": "max",
        "type": "Vector3"
      },
      {
        "name": "min",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(min: Vector3, max: Vector3) => Box3"
      },
      {
        "name": "setFromArray",
        "type": "(array: ArrayLike<number>) => Box3"
      },
      {
        "name": "setFromPoints",
        "type": "(points: Vector3[]) => Box3"
      },
      {
        "name": "setFromCenterAndSize",
        "type": "(center: Vector3, size: Vector3) => Box3"
      },
      {
        "name": "setFromObject",
        "type": "(object: Object3D) => Box3"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(box: this) => this"
      },
      {
        "name": "makeEmpty",
        "type": "() => Box3"
      },
      {
        "name": "isEmpty",
        "type": "() => boolean"
      },
      {
        "name": "getCenter",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "getSize",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "expandByPoint",
        "type": "(point: Vector3) => Box3"
      },
      {
        "name": "expandByVector",
        "type": "(vector: Vector3) => Box3"
      },
      {
        "name": "expandByScalar",
        "type": "(scalar: number) => Box3"
      },
      {
        "name": "expandByObject",
        "type": "(object: Object3D) => Box3"
      },
      {
        "name": "containsPoint",
        "type": "(point: Vector3) => boolean"
      },
      {
        "name": "containsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "getParameter",
        "type": "(point: Vector3) => Vector3"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "intersectsSphere",
        "type": "(sphere: Sphere) => boolean"
      },
      {
        "name": "intersectsPlane",
        "type": "(plane: Plane) => boolean"
      },
      {
        "name": "clampPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "distanceToPoint",
        "type": "(point: Vector3) => number"
      },
      {
        "name": "getBoundingSphere",
        "type": "(optionalTarget?: Sphere) => Sphere"
      },
      {
        "name": "intersect",
        "type": "(box: Box3) => Box3"
      },
      {
        "name": "union",
        "type": "(box: Box3) => Box3"
      },
      {
        "name": "applyMatrix4",
        "type": "(matrix: Matrix4) => Box3"
      },
      {
        "name": "translate",
        "type": "(offset: Vector3) => Box3"
      },
      {
        "name": "equals",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "empty",
        "type": "() => any"
      },
      {
        "name": "isIntersectionBox",
        "type": "(b: any) => any"
      },
      {
        "name": "isIntersectionSphere",
        "type": "(s: any) => any"
      }
    ]
  },
  {
    "name": "HSL",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "s",
        "type": "number"
      },
      {
        "name": "l",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "Color",
    "type": "typeof Color",
    "documentation": "Represents a color. See also {@link ColorUtils}.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "color?",
            "type": "Color"
          }
        ],
        "returnType": "Color"
      },
      {
        "parameters": [
          {
            "name": "color?",
            "type": "string"
          }
        ],
        "returnType": "Color"
      },
      {
        "parameters": [
          {
            "name": "color?",
            "type": "number"
          }
        ],
        "returnType": "Color"
      },
      {
        "parameters": [
          {
            "name": "r",
            "type": "number"
          },
          {
            "name": "g",
            "type": "number"
          },
          {
            "name": "b",
            "type": "number"
          }
        ],
        "returnType": "Color"
      }
    ],
    "properties": [
      {
        "name": "r",
        "type": "number",
        "documentation": "Red channel value between 0 and 1. Default is 1."
      },
      {
        "name": "g",
        "type": "number",
        "documentation": "Green channel value between 0 and 1. Default is 1."
      },
      {
        "name": "b",
        "type": "number",
        "documentation": "Blue channel value between 0 and 1. Default is 1."
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "{ (color: Color): Color; (color: number): Color; (color: string): Color; }"
      },
      {
        "name": "setScalar",
        "type": "(scalar: number) => Color"
      },
      {
        "name": "setHex",
        "type": "(hex: number) => Color"
      },
      {
        "name": "setRGB",
        "type": "(r: number, g: number, b: number) => Color",
        "documentation": "Sets this color from RGB values."
      },
      {
        "name": "setHSL",
        "type": "(h: number, s: number, l: number) => Color",
        "documentation": "Sets this color from HSL values.\r\nBased on MochiKit implementation by Bob Ippolito."
      },
      {
        "name": "setStyle",
        "type": "(style: string) => Color",
        "documentation": "Sets this color from a CSS context style string."
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Clones this color."
      },
      {
        "name": "copy",
        "type": "(color: this) => this",
        "documentation": "Copies given color."
      },
      {
        "name": "copyGammaToLinear",
        "type": "(color: Color, gammaFactor?: number) => Color",
        "documentation": "Copies given color making conversion from gamma to linear space."
      },
      {
        "name": "copyLinearToGamma",
        "type": "(color: Color, gammaFactor?: number) => Color",
        "documentation": "Copies given color making conversion from linear to gamma space."
      },
      {
        "name": "convertGammaToLinear",
        "type": "() => Color",
        "documentation": "Converts this color from gamma to linear space."
      },
      {
        "name": "convertLinearToGamma",
        "type": "() => Color",
        "documentation": "Converts this color from linear to gamma space."
      },
      {
        "name": "getHex",
        "type": "() => number",
        "documentation": "Returns the hexadecimal value of this color."
      },
      {
        "name": "getHexString",
        "type": "() => string",
        "documentation": "Returns the string formated hexadecimal value of this color."
      },
      {
        "name": "getHSL",
        "type": "() => HSL"
      },
      {
        "name": "getStyle",
        "type": "() => string",
        "documentation": "Returns the value of this color in CSS context style.\r\nExample: rgb(r, g, b)"
      },
      {
        "name": "offsetHSL",
        "type": "(h: number, s: number, l: number) => Color"
      },
      {
        "name": "add",
        "type": "(color: Color) => Color"
      },
      {
        "name": "addColors",
        "type": "(color1: Color, color2: Color) => Color"
      },
      {
        "name": "addScalar",
        "type": "(s: number) => Color"
      },
      {
        "name": "sub",
        "type": "(color: Color) => Color"
      },
      {
        "name": "multiply",
        "type": "(color: Color) => Color"
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Color"
      },
      {
        "name": "lerp",
        "type": "(color: Color, alpha: number) => Color"
      },
      {
        "name": "equals",
        "type": "(color: Color) => boolean"
      },
      {
        "name": "fromArray",
        "type": "(rgb: number[], offset?: number) => Color"
      },
      {
        "name": "toArray",
        "type": "(array?: number[], offset?: number) => number[]"
      }
    ]
  },
  {
    "name": "Euler",
    "type": "typeof Euler",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number"
          },
          {
            "name": "y?",
            "type": "number"
          },
          {
            "name": "z?",
            "type": "number"
          },
          {
            "name": "order?",
            "type": "string"
          }
        ],
        "returnType": "Euler"
      }
    ],
    "properties": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "order",
        "type": "string"
      },
      {
        "name": "onChangeCallback",
        "type": "Function"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(x: number, y: number, z: number, order?: string) => Euler"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(euler: this) => this"
      },
      {
        "name": "setFromRotationMatrix",
        "type": "(m: Matrix4, order?: string, update?: boolean) => Euler"
      },
      {
        "name": "setFromQuaternion",
        "type": "(q: Quaternion, order?: string, update?: boolean) => Euler"
      },
      {
        "name": "setFromVector3",
        "type": "(v: Vector3, order?: string) => Euler"
      },
      {
        "name": "reorder",
        "type": "(newOrder: string) => Euler"
      },
      {
        "name": "equals",
        "type": "(euler: Euler) => boolean"
      },
      {
        "name": "fromArray",
        "type": "(xyzo: any[]) => Euler"
      },
      {
        "name": "toArray",
        "type": "(array?: number[], offset?: number) => number[]"
      },
      {
        "name": "toVector3",
        "type": "(optionalResult?: Vector3) => Vector3"
      },
      {
        "name": "onChange",
        "type": "(callback: Function) => void"
      }
    ]
  },
  {
    "name": "Frustum",
    "type": "typeof Frustum",
    "documentation": "Frustums are used to determine what is inside the camera's field of view. They help speed up the rendering process.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "p0?",
            "type": "Plane"
          },
          {
            "name": "p1?",
            "type": "Plane"
          },
          {
            "name": "p2?",
            "type": "Plane"
          },
          {
            "name": "p3?",
            "type": "Plane"
          },
          {
            "name": "p4?",
            "type": "Plane"
          },
          {
            "name": "p5?",
            "type": "Plane"
          }
        ],
        "returnType": "Frustum"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "planes",
        "type": "Plane[]",
        "documentation": "Array of 6 vectors."
      },
      {
        "name": "set",
        "type": "(p0?: number, p1?: number, p2?: number, p3?: number, p4?: number, p5?: number) => Frustum"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(frustum: this) => this"
      },
      {
        "name": "setFromMatrix",
        "type": "(m: Matrix4) => Frustum"
      },
      {
        "name": "intersectsObject",
        "type": "{ (object: Object3D): boolean; (sprite: Sprite): boolean; }"
      },
      {
        "name": "intersectsSphere",
        "type": "(sphere: Sphere) => boolean"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "containsPoint",
        "type": "(point: Vector3) => boolean"
      }
    ]
  },
  {
    "name": "Line3",
    "type": "typeof Line3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "start?",
            "type": "Vector3"
          },
          {
            "name": "end?",
            "type": "Vector3"
          }
        ],
        "returnType": "Line3"
      }
    ],
    "properties": [
      {
        "name": "start",
        "type": "Vector3"
      },
      {
        "name": "end",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(start?: Vector3, end?: Vector3) => Line3"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(line: this) => this"
      },
      {
        "name": "getCenter",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "delta",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "distanceSq",
        "type": "() => number"
      },
      {
        "name": "distance",
        "type": "() => number"
      },
      {
        "name": "at",
        "type": "(t: number, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "closestPointToPointParameter",
        "type": "(point: Vector3, clampToLine?: boolean) => number"
      },
      {
        "name": "closestPointToPoint",
        "type": "(point: Vector3, clampToLine?: boolean, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "applyMatrix4",
        "type": "(matrix: Matrix4) => Line3"
      },
      {
        "name": "equals",
        "type": "(line: Line3) => boolean"
      }
    ]
  },
  {
    "name": "Matrix",
    "type": "any",
    "documentation": "( interface Matrix&lt;T&gt; )",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "identity",
        "type": "() => Matrix",
        "documentation": "identity():T;"
      },
      {
        "name": "copy",
        "type": "(m: this) => this",
        "documentation": "copy(m:T):T;"
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Matrix",
        "documentation": "multiplyScalar(s:number):T;"
      },
      {
        "name": "determinant",
        "type": "() => number"
      },
      {
        "name": "getInverse",
        "type": "(matrix: Matrix, throwOnInvertible?: boolean) => Matrix",
        "documentation": "getInverse(matrix:T, throwOnInvertible?:boolean):T;"
      },
      {
        "name": "transpose",
        "type": "() => Matrix",
        "documentation": "transpose():T;"
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "clone():T;"
      }
    ]
  },
  {
    "name": "Matrix3",
    "type": "typeof Matrix3",
    "documentation": "( class Matrix3 implements Matrix&lt;Matrix3&gt; )",
    "constructors": [
      {
        "documentation": "Creates an identity matrix.",
        "returnType": "Matrix3"
      }
    ],
    "properties": [
      {
        "name": "elements",
        "type": "Float32Array",
        "documentation": "Float32Array with matrix values."
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: ..."
      },
      {
        "name": "identity",
        "type": "() => Matrix3"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(m: this) => this"
      },
      {
        "name": "setFromMatrix4",
        "type": "(m: Matrix4) => Matrix3"
      },
      {
        "name": "applyToBuffer",
        "type": "(buffer: BufferAttribute, offset?: number, length?: number) => BufferAttribute"
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Matrix3"
      },
      {
        "name": "determinant",
        "type": "() => number"
      },
      {
        "name": "getInverse",
        "type": "{ (matrix: Matrix3, throwOnDegenerate?: boolean): Matrix3; (matrix: Matrix4, throwOnDegenerate?: ..."
      },
      {
        "name": "transpose",
        "type": "() => Matrix3",
        "documentation": "Transposes this matrix in place."
      },
      {
        "name": "getNormalMatrix",
        "type": "(matrix4: Matrix4) => Matrix3"
      },
      {
        "name": "transposeIntoArray",
        "type": "(r: number[]) => number[]",
        "documentation": "Transposes this matrix into the supplied array r, and returns itself."
      },
      {
        "name": "fromArray",
        "type": "(array: number[], offset?: number) => Matrix3"
      },
      {
        "name": "toArray",
        "type": "() => number[]"
      },
      {
        "name": "multiply",
        "type": "(m: Matrix3) => Matrix3",
        "documentation": "Multiplies this matrix by m."
      },
      {
        "name": "premultiply",
        "type": "(m: Matrix3) => Matrix3"
      },
      {
        "name": "multiplyMatrices",
        "type": "(a: Matrix3, b: Matrix3) => Matrix3",
        "documentation": "Sets this matrix to a x b."
      },
      {
        "name": "multiplyVector3",
        "type": "(vector: Vector3) => any"
      },
      {
        "name": "multiplyVector3Array",
        "type": "(a: any) => any"
      },
      {
        "name": "flattenToArrayOffset",
        "type": "(array: number[], offset: number) => number[]"
      }
    ]
  },
  {
    "name": "Matrix4",
    "type": "typeof Matrix4",
    "documentation": "A 4x4 Matrix.",
    "constructors": [
      {
        "returnType": "Matrix4"
      }
    ],
    "properties": [
      {
        "name": "elements",
        "type": "Float32Array",
        "documentation": "Float32Array with matrix values."
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: ...",
        "documentation": "Sets all fields of this matrix."
      },
      {
        "name": "identity",
        "type": "() => Matrix4",
        "documentation": "Resets this matrix to identity."
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(m: this) => this"
      },
      {
        "name": "copyPosition",
        "type": "(m: Matrix4) => Matrix4"
      },
      {
        "name": "extractBasis",
        "type": "(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4"
      },
      {
        "name": "makeBasis",
        "type": "(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4"
      },
      {
        "name": "extractRotation",
        "type": "(m: Matrix4) => Matrix4",
        "documentation": "Copies the rotation component of the supplied matrix m into this matrix rotation component."
      },
      {
        "name": "makeRotationFromEuler",
        "type": "(euler: Euler) => Matrix4"
      },
      {
        "name": "makeRotationFromQuaternion",
        "type": "(q: Quaternion) => Matrix4"
      },
      {
        "name": "lookAt",
        "type": "(eye: Vector3, target: Vector3, up: Vector3) => Matrix4",
        "documentation": "Constructs a rotation matrix, looking from eye towards center with defined up vector."
      },
      {
        "name": "multiply",
        "type": "(m: Matrix4) => Matrix4",
        "documentation": "Multiplies this matrix by m."
      },
      {
        "name": "premultiply",
        "type": "(m: Matrix4) => Matrix4"
      },
      {
        "name": "multiplyMatrices",
        "type": "(a: Matrix4, b: Matrix4) => Matrix4",
        "documentation": "Sets this matrix to a x b."
      },
      {
        "name": "multiplyToArray",
        "type": "(a: Matrix4, b: Matrix4, r: number[]) => Matrix4",
        "documentation": "Sets this matrix to a x b and stores the result into the flat array r.\r\nr can be either a regular Array or a TypedArray."
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Matrix4",
        "documentation": "Multiplies this matrix by s."
      },
      {
        "name": "applyToBuffer",
        "type": "(buffer: BufferAttribute, offset?: number, length?: number) => BufferAttribute"
      },
      {
        "name": "determinant",
        "type": "() => number",
        "documentation": "Computes determinant of this matrix.\r\nBased on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm"
      },
      {
        "name": "transpose",
        "type": "() => Matrix4",
        "documentation": "Transposes this matrix."
      },
      {
        "name": "setPosition",
        "type": "(v: Vector3) => Matrix4",
        "documentation": "Sets the position component for this matrix from vector v."
      },
      {
        "name": "getInverse",
        "type": "(m: Matrix4, throwOnDegeneratee?: boolean) => Matrix4",
        "documentation": "Sets this matrix to the inverse of matrix m.\r\nBased on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm."
      },
      {
        "name": "scale",
        "type": "(v: Vector3) => Matrix4",
        "documentation": "Multiplies the columns of this matrix by vector v."
      },
      {
        "name": "getMaxScaleOnAxis",
        "type": "() => number"
      },
      {
        "name": "makeTranslation",
        "type": "(x: number, y: number, z: number) => Matrix4",
        "documentation": "Sets this matrix as translation transform."
      },
      {
        "name": "makeRotationX",
        "type": "(theta: number) => Matrix4",
        "documentation": "Sets this matrix as rotation transform around x axis by theta radians."
      },
      {
        "name": "makeRotationY",
        "type": "(theta: number) => Matrix4",
        "documentation": "Sets this matrix as rotation transform around y axis by theta radians."
      },
      {
        "name": "makeRotationZ",
        "type": "(theta: number) => Matrix4",
        "documentation": "Sets this matrix as rotation transform around z axis by theta radians."
      },
      {
        "name": "makeRotationAxis",
        "type": "(axis: Vector3, angle: number) => Matrix4",
        "documentation": "Sets this matrix as rotation transform around axis by angle radians.\r\nBased on http://www.gamedev.net/reference/articles/article1199.asp."
      },
      {
        "name": "makeScale",
        "type": "(x: number, y: number, z: number) => Matrix4",
        "documentation": "Sets this matrix as scale transform."
      },
      {
        "name": "compose",
        "type": "(translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4",
        "documentation": "Sets this matrix to the transformation composed of translation, rotation and scale."
      },
      {
        "name": "decompose",
        "type": "(translation?: Vector3, rotation?: Quaternion, scale?: Vector3) => Object[]",
        "documentation": "Decomposes this matrix into the translation, rotation and scale components.\r\nIf parameters are not passed, new instances will be created."
      },
      {
        "name": "makePerspective",
        "type": "{ (left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;...",
        "documentation": "Creates a frustum matrix.\nCreates a perspective projection matrix."
      },
      {
        "name": "makeOrthographic",
        "type": "(left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4",
        "documentation": "Creates an orthographic projection matrix."
      },
      {
        "name": "equals",
        "type": "(matrix: Matrix4) => boolean"
      },
      {
        "name": "fromArray",
        "type": "(array: number[], offset?: number) => Matrix4"
      },
      {
        "name": "toArray",
        "type": "() => number[]"
      },
      {
        "name": "extractPosition",
        "type": "(m: Matrix4) => Matrix4"
      },
      {
        "name": "setRotationFromQuaternion",
        "type": "(q: Quaternion) => Matrix4"
      },
      {
        "name": "multiplyVector3",
        "type": "(v: any) => any"
      },
      {
        "name": "multiplyVector4",
        "type": "(v: any) => any"
      },
      {
        "name": "multiplyVector3Array",
        "type": "(array: number[]) => number[]"
      },
      {
        "name": "rotateAxis",
        "type": "(v: any) => void"
      },
      {
        "name": "crossVector",
        "type": "(v: any) => void"
      },
      {
        "name": "flattenToArrayOffset",
        "type": "(array: number[], offset: number) => number[]"
      }
    ]
  },
  {
    "name": "Plane",
    "type": "typeof Plane",
    "constructors": [
      {
        "parameters": [
          {
            "name": "normal?",
            "type": "Vector3"
          },
          {
            "name": "constant?",
            "type": "number"
          }
        ],
        "returnType": "Plane"
      }
    ],
    "properties": [
      {
        "name": "normal",
        "type": "Vector3"
      },
      {
        "name": "constant",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(normal: Vector3, constant: number) => Plane"
      },
      {
        "name": "setComponents",
        "type": "(x: number, y: number, z: number, w: number) => Plane"
      },
      {
        "name": "setFromNormalAndCoplanarPoint",
        "type": "(normal: Vector3, point: Vector3) => Plane"
      },
      {
        "name": "setFromCoplanarPoints",
        "type": "(a: Vector3, b: Vector3, c: Vector3) => Plane"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(plane: this) => this"
      },
      {
        "name": "normalize",
        "type": "() => Plane"
      },
      {
        "name": "negate",
        "type": "() => Plane"
      },
      {
        "name": "distanceToPoint",
        "type": "(point: Vector3) => number"
      },
      {
        "name": "distanceToSphere",
        "type": "(sphere: Sphere) => number"
      },
      {
        "name": "projectPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "orthoPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "intersectLine",
        "type": "(line: Line3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "intersectsLine",
        "type": "(line: Line3) => boolean"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "coplanarPoint",
        "type": "(optionalTarget?: boolean) => Vector3"
      },
      {
        "name": "applyMatrix4",
        "type": "(matrix: Matrix4, optionalNormalMatrix?: Matrix3) => Plane"
      },
      {
        "name": "translate",
        "type": "(offset: Vector3) => Plane"
      },
      {
        "name": "equals",
        "type": "(plane: Plane) => boolean"
      },
      {
        "name": "isIntersectionLine",
        "type": "(l: any) => any"
      }
    ]
  },
  {
    "name": "Spherical",
    "type": "typeof Spherical",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "phi?",
            "type": "number"
          },
          {
            "name": "theta?",
            "type": "number"
          }
        ],
        "returnType": "Spherical"
      }
    ],
    "properties": [
      {
        "name": "radius",
        "type": "number"
      },
      {
        "name": "phi",
        "type": "number"
      },
      {
        "name": "theta",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(radius: number, phi: number, theta: number) => Spherical"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(other: this) => this"
      },
      {
        "name": "makeSafe",
        "type": "() => void"
      },
      {
        "name": "setFromVector3",
        "type": "(vec3: Vector3) => Spherical"
      }
    ]
  },
  {
    "name": "Quaternion",
    "type": "typeof Quaternion",
    "documentation": "Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number",
            "documentation": "x coordinate"
          },
          {
            "name": "y?",
            "type": "number",
            "documentation": "y coordinate"
          },
          {
            "name": "z?",
            "type": "number",
            "documentation": "z coordinate"
          },
          {
            "name": "w?",
            "type": "number",
            "documentation": "w coordinate"
          }
        ],
        "returnType": "Quaternion"
      }
    ],
    "properties": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "w",
        "type": "number"
      },
      {
        "name": "onChangeCallback",
        "type": "Function"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(x: number, y: number, z: number, w: number) => Quaternion",
        "documentation": "Sets values of this quaternion."
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Clones this quaternion."
      },
      {
        "name": "copy",
        "type": "(q: this) => this",
        "documentation": "Copies values of q to this quaternion."
      },
      {
        "name": "setFromEuler",
        "type": "(euler: Euler, update?: boolean) => Quaternion",
        "documentation": "Sets this quaternion from rotation specified by Euler angles."
      },
      {
        "name": "setFromAxisAngle",
        "type": "(axis: Vector3, angle: number) => Quaternion",
        "documentation": "Sets this quaternion from rotation specified by axis and angle.\r\nAdapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.\r\nAxis have to be normalized, angle is in radians."
      },
      {
        "name": "setFromRotationMatrix",
        "type": "(m: Matrix4) => Quaternion",
        "documentation": "Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm."
      },
      {
        "name": "setFromUnitVectors",
        "type": "(vFrom: Vector3, vTo: Vector3) => Quaternion"
      },
      {
        "name": "inverse",
        "type": "() => Quaternion",
        "documentation": "Inverts this quaternion."
      },
      {
        "name": "conjugate",
        "type": "() => Quaternion"
      },
      {
        "name": "dot",
        "type": "(v: Quaternion) => number"
      },
      {
        "name": "lengthSq",
        "type": "() => number"
      },
      {
        "name": "length",
        "type": "() => number",
        "documentation": "Computes length of this quaternion."
      },
      {
        "name": "normalize",
        "type": "() => Quaternion",
        "documentation": "Normalizes this quaternion."
      },
      {
        "name": "multiply",
        "type": "(q: Quaternion) => Quaternion",
        "documentation": "Multiplies this quaternion by b."
      },
      {
        "name": "premultiply",
        "type": "(q: Quaternion) => Quaternion"
      },
      {
        "name": "multiplyQuaternions",
        "type": "(a: Quaternion, b: Quaternion) => Quaternion",
        "documentation": "Sets this quaternion to a x b\r\nAdapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm."
      },
      {
        "name": "slerp",
        "type": "(qb: Quaternion, t: number) => Quaternion"
      },
      {
        "name": "equals",
        "type": "(v: Quaternion) => boolean"
      },
      {
        "name": "fromArray",
        "type": "{ (n: number[]): Quaternion; (xyzw: number[], offset?: number): Quaternion; }"
      },
      {
        "name": "toArray",
        "type": "{ (): number[]; (xyzw?: number[], offset?: number): number[]; }"
      },
      {
        "name": "onChange",
        "type": "(callback: Function) => Quaternion"
      },
      {
        "name": "multiplyVector3",
        "type": "(v: any) => any"
      }
    ]
  },
  {
    "name": "Ray",
    "type": "typeof Ray",
    "constructors": [
      {
        "parameters": [
          {
            "name": "origin?",
            "type": "Vector3"
          },
          {
            "name": "direction?",
            "type": "Vector3"
          }
        ],
        "returnType": "Ray"
      }
    ],
    "properties": [
      {
        "name": "origin",
        "type": "Vector3"
      },
      {
        "name": "direction",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(origin: Vector3, direction: Vector3) => Ray"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(ray: this) => this"
      },
      {
        "name": "at",
        "type": "(t: number, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "lookAt",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "recast",
        "type": "(t: number) => Ray"
      },
      {
        "name": "closestPointToPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "distanceToPoint",
        "type": "(point: Vector3) => number"
      },
      {
        "name": "distanceSqToPoint",
        "type": "(point: Vector3) => number"
      },
      {
        "name": "distanceSqToSegment",
        "type": "(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3) => num..."
      },
      {
        "name": "intersectSphere",
        "type": "(sphere: Sphere, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "intersectsSphere",
        "type": "(sphere: Sphere) => boolean"
      },
      {
        "name": "distanceToPlane",
        "type": "(plane: Plane) => number"
      },
      {
        "name": "intersectPlane",
        "type": "(plane: Plane, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "intersectsPlane",
        "type": "(plane: Plane) => boolean"
      },
      {
        "name": "intersectBox",
        "type": "(box: Box3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "intersectTriangle",
        "type": "(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "applyMatrix4",
        "type": "(matrix4: Matrix4) => Ray"
      },
      {
        "name": "equals",
        "type": "(ray: Ray) => boolean"
      },
      {
        "name": "isIntersectionBox",
        "type": "(b: any) => any"
      },
      {
        "name": "isIntersectionPlane",
        "type": "(p: any) => any"
      },
      {
        "name": "isIntersectionSphere",
        "type": "(s: any) => any"
      }
    ]
  },
  {
    "name": "Sphere",
    "type": "typeof Sphere",
    "constructors": [
      {
        "parameters": [
          {
            "name": "center?",
            "type": "Vector3"
          },
          {
            "name": "radius?",
            "type": "number"
          }
        ],
        "returnType": "Sphere"
      }
    ],
    "properties": [
      {
        "name": "center",
        "type": "Vector3"
      },
      {
        "name": "radius",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(center: Vector3, radius: number) => Sphere"
      },
      {
        "name": "setFromPoints",
        "type": "(points: Vector3[], optionalCenter?: Vector3) => Sphere"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(sphere: this) => this"
      },
      {
        "name": "empty",
        "type": "() => boolean"
      },
      {
        "name": "containsPoint",
        "type": "(point: Vector3) => boolean"
      },
      {
        "name": "distanceToPoint",
        "type": "(point: Vector3) => number"
      },
      {
        "name": "intersectsSphere",
        "type": "(sphere: Sphere) => boolean"
      },
      {
        "name": "intersectsBox",
        "type": "(box: Box3) => boolean"
      },
      {
        "name": "intersectsPlane",
        "type": "(plane: Plane) => boolean"
      },
      {
        "name": "clampPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "getBoundingBox",
        "type": "(optionalTarget?: Box3) => Box3"
      },
      {
        "name": "applyMatrix4",
        "type": "(matrix: Matrix4) => Sphere"
      },
      {
        "name": "translate",
        "type": "(offset: Vector3) => Sphere"
      },
      {
        "name": "equals",
        "type": "(sphere: Sphere) => boolean"
      }
    ]
  },
  {
    "name": "SplineControlPoint",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "Triangle",
    "type": "typeof Triangle",
    "constructors": [
      {
        "parameters": [
          {
            "name": "a?",
            "type": "Vector3"
          },
          {
            "name": "b?",
            "type": "Vector3"
          },
          {
            "name": "c?",
            "type": "Vector3"
          }
        ],
        "returnType": "Triangle"
      }
    ],
    "properties": [
      {
        "name": "a",
        "type": "Vector3"
      },
      {
        "name": "b",
        "type": "Vector3"
      },
      {
        "name": "c",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(a: Vector3, b: Vector3, c: Vector3) => Triangle"
      },
      {
        "name": "setFromPointsAndIndices",
        "type": "(points: Vector3[], i0: number, i1: number, i2: number) => Triangle"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(triangle: this) => this"
      },
      {
        "name": "area",
        "type": "() => number"
      },
      {
        "name": "midpoint",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "normal",
        "type": "(optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "plane",
        "type": "(optionalTarget?: Vector3) => Plane"
      },
      {
        "name": "barycoordFromPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "containsPoint",
        "type": "(point: Vector3) => boolean"
      },
      {
        "name": "closestPointToPoint",
        "type": "(point: Vector3, optionalTarget?: Vector3) => Vector3"
      },
      {
        "name": "equals",
        "type": "(triangle: Triangle) => boolean"
      }
    ]
  },
  {
    "name": "Vector",
    "type": "any",
    "documentation": "( interface Vector&lt;T&gt; )\r\n\r\nAbstract interface of Vector2, Vector3 and Vector4.\r\nCurrently the members of Vector is NOT type safe because it accepts different typed vectors.\r\nThose definitions will be changed when TypeScript innovates Generics to be type safe.",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "getComponent",
        "type": "(index: number) => number"
      },
      {
        "name": "copy",
        "type": "(v: this) => this",
        "documentation": "copy(v:T):T;"
      },
      {
        "name": "add",
        "type": "(v: Vector) => Vector",
        "documentation": "add(v:T):T;"
      },
      {
        "name": "addVectors",
        "type": "(a: Vector, b: Vector) => Vector",
        "documentation": "addVectors(a:T, b:T):T;"
      },
      {
        "name": "sub",
        "type": "(v: Vector) => Vector",
        "documentation": "sub(v:T):T;"
      },
      {
        "name": "subVectors",
        "type": "(a: Vector, b: Vector) => Vector",
        "documentation": "subVectors(a:T, b:T):T;"
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Vector",
        "documentation": "multiplyScalar(s:number):T;"
      },
      {
        "name": "divideScalar",
        "type": "(s: number) => Vector",
        "documentation": "divideScalar(s:number):T;"
      },
      {
        "name": "negate",
        "type": "() => Vector",
        "documentation": "negate():T;"
      },
      {
        "name": "dot",
        "type": "(v: Vector) => number",
        "documentation": "dot(v:T):T;"
      },
      {
        "name": "lengthSq",
        "type": "() => number",
        "documentation": "lengthSq():number;"
      },
      {
        "name": "length",
        "type": "() => number",
        "documentation": "length():number;"
      },
      {
        "name": "normalize",
        "type": "() => Vector",
        "documentation": "normalize():T;"
      },
      {
        "name": "distanceTo?",
        "type": "(v: Vector) => number",
        "documentation": "NOTE: Vector4 doesn't have the property.\r\n\r\ndistanceTo(v:T):number;"
      },
      {
        "name": "distanceToSquared?",
        "type": "(v: Vector) => number",
        "documentation": "NOTE: Vector4 doesn't have the property.\r\n\r\ndistanceToSquared(v:T):number;"
      },
      {
        "name": "setLength",
        "type": "(l: number) => Vector",
        "documentation": "setLength(l:number):T;"
      },
      {
        "name": "lerp",
        "type": "(v: Vector, alpha: number) => Vector",
        "documentation": "lerp(v:T, alpha:number):T;"
      },
      {
        "name": "equals",
        "type": "(v: Vector) => boolean",
        "documentation": "equals(v:T):boolean;"
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "clone():T;"
      }
    ]
  },
  {
    "name": "Vector2",
    "type": "typeof Vector2",
    "documentation": "2D vector.\r\n\r\n( class Vector2 implements Vector<Vector2> )",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number"
          },
          {
            "name": "y?",
            "type": "number"
          }
        ],
        "returnType": "Vector2"
      }
    ],
    "properties": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "width",
        "type": "number"
      },
      {
        "name": "height",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(x: number, y: number) => Vector2",
        "documentation": "Sets value of this vector."
      },
      {
        "name": "setScalar",
        "type": "(scalar: number) => Vector2"
      },
      {
        "name": "setX",
        "type": "(x: number) => Vector2",
        "documentation": "Sets X component of this vector."
      },
      {
        "name": "setY",
        "type": "(y: number) => Vector2",
        "documentation": "Sets Y component of this vector."
      },
      {
        "name": "setComponent",
        "type": "(index: number, value: number) => void",
        "documentation": "Sets a component of this vector."
      },
      {
        "name": "getComponent",
        "type": "(index: number) => number",
        "documentation": "Gets a component of this vector."
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Clones this vector."
      },
      {
        "name": "copy",
        "type": "(v: this) => this",
        "documentation": "Copies value of v to this vector."
      },
      {
        "name": "add",
        "type": "(v: Vector2) => Vector2",
        "documentation": "Adds v to this vector."
      },
      {
        "name": "addScalar",
        "type": "(s: number) => Vector2",
        "documentation": "Sets this vector to a + b."
      },
      {
        "name": "addVectors",
        "type": "(a: Vector2, b: Vector2) => Vector2"
      },
      {
        "name": "addScaledVector",
        "type": "(v: Vector2, s: number) => Vector2"
      },
      {
        "name": "sub",
        "type": "(v: Vector2) => Vector2",
        "documentation": "Subtracts v from this vector."
      },
      {
        "name": "subVectors",
        "type": "(a: Vector2, b: Vector2) => Vector2",
        "documentation": "Sets this vector to a - b."
      },
      {
        "name": "multiply",
        "type": "(v: Vector2) => Vector2"
      },
      {
        "name": "multiplyScalar",
        "type": "(scalar: number) => Vector2",
        "documentation": "Multiplies this vector by scalar s."
      },
      {
        "name": "divide",
        "type": "(v: Vector2) => Vector2"
      },
      {
        "name": "divideScalar",
        "type": "(s: number) => Vector2",
        "documentation": "Divides this vector by scalar s.\r\nSet vector to ( 0, 0 ) if s == 0."
      },
      {
        "name": "min",
        "type": "(v: Vector2) => Vector2"
      },
      {
        "name": "max",
        "type": "(v: Vector2) => Vector2"
      },
      {
        "name": "clamp",
        "type": "(min: Vector2, max: Vector2) => Vector2"
      },
      {
        "name": "clampScalar",
        "type": "(min: number, max: number) => Vector2"
      },
      {
        "name": "clampLength",
        "type": "(min: number, max: number) => Vector2"
      },
      {
        "name": "floor",
        "type": "() => Vector2"
      },
      {
        "name": "ceil",
        "type": "() => Vector2"
      },
      {
        "name": "round",
        "type": "() => Vector2"
      },
      {
        "name": "roundToZero",
        "type": "() => Vector2"
      },
      {
        "name": "negate",
        "type": "() => Vector2",
        "documentation": "Inverts this vector."
      },
      {
        "name": "dot",
        "type": "(v: Vector2) => number",
        "documentation": "Computes dot product of this vector and v."
      },
      {
        "name": "lengthSq",
        "type": "() => number",
        "documentation": "Computes squared length of this vector."
      },
      {
        "name": "length",
        "type": "() => number",
        "documentation": "Computes length of this vector."
      },
      {
        "name": "lengthManhattan",
        "type": "() => number"
      },
      {
        "name": "normalize",
        "type": "() => Vector2",
        "documentation": "Normalizes this vector."
      },
      {
        "name": "angle",
        "type": "() => number",
        "documentation": "computes the angle in radians with respect to the positive x-axis"
      },
      {
        "name": "distanceTo",
        "type": "(v: Vector2) => number",
        "documentation": "Computes distance of this vector to v."
      },
      {
        "name": "distanceToSquared",
        "type": "(v: Vector2) => number",
        "documentation": "Computes squared distance of this vector to v."
      },
      {
        "name": "distanceToManhattan",
        "type": "(v: Vector2) => number"
      },
      {
        "name": "setLength",
        "type": "(length: number) => Vector2",
        "documentation": "Normalizes this vector and multiplies it by l."
      },
      {
        "name": "lerp",
        "type": "(v: Vector2, alpha: number) => Vector2"
      },
      {
        "name": "lerpVectors",
        "type": "(v1: Vector2, v2: Vector2, alpha: number) => Vector2"
      },
      {
        "name": "equals",
        "type": "(v: Vector2) => boolean",
        "documentation": "Checks for strict equality of this vector and v."
      },
      {
        "name": "fromArray",
        "type": "(xy: number[], offset?: number) => Vector2"
      },
      {
        "name": "toArray",
        "type": "(xy?: number[], offset?: number) => number[]"
      },
      {
        "name": "fromBufferAttribute",
        "type": "(attribute: BufferAttribute, index: number, offset?: number) => Vector2"
      },
      {
        "name": "rotateAround",
        "type": "(center: Vector2, angle: number) => Vector2"
      }
    ]
  },
  {
    "name": "Vector3",
    "type": "typeof Vector3",
    "documentation": "3D vector.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number"
          },
          {
            "name": "y?",
            "type": "number"
          },
          {
            "name": "z?",
            "type": "number"
          }
        ],
        "returnType": "Vector3"
      }
    ],
    "properties": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(x: number, y: number, z: number) => Vector3",
        "documentation": "Sets value of this vector."
      },
      {
        "name": "setScalar",
        "type": "(scalar: number) => Vector3",
        "documentation": "Sets all values of this vector."
      },
      {
        "name": "setX",
        "type": "(x: number) => Vector3",
        "documentation": "Sets x value of this vector."
      },
      {
        "name": "setY",
        "type": "(y: number) => Vector3",
        "documentation": "Sets y value of this vector."
      },
      {
        "name": "setZ",
        "type": "(z: number) => Vector3",
        "documentation": "Sets z value of this vector."
      },
      {
        "name": "setComponent",
        "type": "(index: number, value: number) => void"
      },
      {
        "name": "getComponent",
        "type": "(index: number) => number"
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Clones this vector."
      },
      {
        "name": "copy",
        "type": "(v: this) => this",
        "documentation": "Copies value of v to this vector."
      },
      {
        "name": "add",
        "type": "(a: Vector3) => Vector3",
        "documentation": "Adds v to this vector."
      },
      {
        "name": "addScalar",
        "type": "(s: number) => Vector3"
      },
      {
        "name": "addScaledVector",
        "type": "(v: Vector3, s: number) => Vector3"
      },
      {
        "name": "addVectors",
        "type": "(a: Vector3, b: Vector3) => Vector3",
        "documentation": "Sets this vector to a + b."
      },
      {
        "name": "sub",
        "type": "(a: Vector3) => Vector3",
        "documentation": "Subtracts v from this vector."
      },
      {
        "name": "subScalar",
        "type": "(s: number) => Vector3"
      },
      {
        "name": "subVectors",
        "type": "(a: Vector3, b: Vector3) => Vector3",
        "documentation": "Sets this vector to a - b."
      },
      {
        "name": "multiply",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Vector3",
        "documentation": "Multiplies this vector by scalar s."
      },
      {
        "name": "multiplyVectors",
        "type": "(a: Vector3, b: Vector3) => Vector3"
      },
      {
        "name": "applyEuler",
        "type": "(euler: Euler) => Vector3"
      },
      {
        "name": "applyAxisAngle",
        "type": "(axis: Vector3, angle: number) => Vector3"
      },
      {
        "name": "applyMatrix3",
        "type": "(m: Matrix3) => Vector3"
      },
      {
        "name": "applyMatrix4",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "applyQuaternion",
        "type": "(q: Quaternion) => Vector3"
      },
      {
        "name": "project",
        "type": "(camrea: Camera) => Vector3"
      },
      {
        "name": "unproject",
        "type": "(camera: Camera) => Vector3"
      },
      {
        "name": "transformDirection",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "divide",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "divideScalar",
        "type": "(s: number) => Vector3",
        "documentation": "Divides this vector by scalar s.\r\nSet vector to ( 0, 0, 0 ) if s == 0."
      },
      {
        "name": "min",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "max",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "clamp",
        "type": "(min: Vector3, max: Vector3) => Vector3"
      },
      {
        "name": "clampScalar",
        "type": "(min: number, max: number) => Vector3"
      },
      {
        "name": "clampLength",
        "type": "(min: number, max: number) => Vector3"
      },
      {
        "name": "floor",
        "type": "() => Vector3"
      },
      {
        "name": "ceil",
        "type": "() => Vector3"
      },
      {
        "name": "round",
        "type": "() => Vector3"
      },
      {
        "name": "roundToZero",
        "type": "() => Vector3"
      },
      {
        "name": "negate",
        "type": "() => Vector3",
        "documentation": "Inverts this vector."
      },
      {
        "name": "dot",
        "type": "(v: Vector3) => number",
        "documentation": "Computes dot product of this vector and v."
      },
      {
        "name": "lengthSq",
        "type": "() => number",
        "documentation": "Computes squared length of this vector."
      },
      {
        "name": "length",
        "type": "() => number",
        "documentation": "Computes length of this vector."
      },
      {
        "name": "lengthManhattan",
        "type": "() => number",
        "documentation": "Computes Manhattan length of this vector.\r\nhttp://en.wikipedia.org/wiki/Taxicab_geometry"
      },
      {
        "name": "normalize",
        "type": "() => Vector3",
        "documentation": "Normalizes this vector."
      },
      {
        "name": "setLength",
        "type": "(l: number) => Vector3",
        "documentation": "Normalizes this vector and multiplies it by l."
      },
      {
        "name": "lerp",
        "type": "(v: Vector3, alpha: number) => Vector3"
      },
      {
        "name": "lerpVectors",
        "type": "(v1: Vector3, v2: Vector3, alpha: number) => Vector3"
      },
      {
        "name": "cross",
        "type": "(a: Vector3) => Vector3",
        "documentation": "Sets this vector to cross product of itself and v."
      },
      {
        "name": "crossVectors",
        "type": "(a: Vector3, b: Vector3) => Vector3",
        "documentation": "Sets this vector to cross product of a and b."
      },
      {
        "name": "projectOnVector",
        "type": "(v: Vector3) => Vector3"
      },
      {
        "name": "projectOnPlane",
        "type": "(planeNormal: Vector3) => Vector3"
      },
      {
        "name": "reflect",
        "type": "(vector: Vector3) => Vector3"
      },
      {
        "name": "angleTo",
        "type": "(v: Vector3) => number"
      },
      {
        "name": "distanceTo",
        "type": "(v: Vector3) => number",
        "documentation": "Computes distance of this vector to v."
      },
      {
        "name": "distanceToSquared",
        "type": "(v: Vector3) => number",
        "documentation": "Computes squared distance of this vector to v."
      },
      {
        "name": "distanceToManhattan",
        "type": "(v: Vector3) => number"
      },
      {
        "name": "setFromSpherical",
        "type": "(s: Spherical) => Vector3"
      },
      {
        "name": "setFromMatrixPosition",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "setFromMatrixScale",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "setFromMatrixColumn",
        "type": "(matrix: Matrix4, index: number) => Vector3"
      },
      {
        "name": "equals",
        "type": "(v: Vector3) => boolean",
        "documentation": "Checks for strict equality of this vector and v."
      },
      {
        "name": "fromArray",
        "type": "(xyz: number[], offset?: number) => Vector3"
      },
      {
        "name": "toArray",
        "type": "(xyz?: number[], offset?: number) => number[]"
      },
      {
        "name": "fromBufferAttribute",
        "type": "(attribute: BufferAttribute, index: number, offset?: number) => Vector3"
      },
      {
        "name": "getPositionFromMatrix",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "getScaleFromMatrix",
        "type": "(m: Matrix4) => Vector3"
      },
      {
        "name": "getColumnFromMatrix",
        "type": "(index: number, matrix: Matrix4) => Vector3"
      }
    ]
  },
  {
    "name": "Vertex",
    "type": "typeof Vertex",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number"
          },
          {
            "name": "y?",
            "type": "number"
          },
          {
            "name": "z?",
            "type": "number"
          }
        ],
        "returnType": "Vertex"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Vector4",
    "type": "typeof Vector4",
    "documentation": "4D vector.\r\n\r\n( class Vector4 implements Vector<Vector4> )",
    "constructors": [
      {
        "parameters": [
          {
            "name": "x?",
            "type": "number"
          },
          {
            "name": "y?",
            "type": "number"
          },
          {
            "name": "z?",
            "type": "number"
          },
          {
            "name": "w?",
            "type": "number"
          }
        ],
        "returnType": "Vector4"
      }
    ],
    "properties": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "w",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "set",
        "type": "(x: number, y: number, z: number, w: number) => Vector4",
        "documentation": "Sets value of this vector."
      },
      {
        "name": "setScalar",
        "type": "(scalar: number) => Vector4",
        "documentation": "Sets all values of this vector."
      },
      {
        "name": "setX",
        "type": "(x: number) => Vector4",
        "documentation": "Sets X component of this vector."
      },
      {
        "name": "setY",
        "type": "(y: number) => Vector4",
        "documentation": "Sets Y component of this vector."
      },
      {
        "name": "setZ",
        "type": "(z: number) => Vector4",
        "documentation": "Sets Z component of this vector."
      },
      {
        "name": "setW",
        "type": "(w: number) => Vector4",
        "documentation": "Sets w component of this vector."
      },
      {
        "name": "setComponent",
        "type": "(index: number, value: number) => void"
      },
      {
        "name": "getComponent",
        "type": "(index: number) => number"
      },
      {
        "name": "clone",
        "type": "() => this",
        "documentation": "Clones this vector."
      },
      {
        "name": "copy",
        "type": "(v: this) => this",
        "documentation": "Copies value of v to this vector."
      },
      {
        "name": "add",
        "type": "(v: Vector4) => Vector4",
        "documentation": "Adds v to this vector."
      },
      {
        "name": "addScalar",
        "type": "(s: number) => Vector4"
      },
      {
        "name": "addVectors",
        "type": "(a: Vector4, b: Vector4) => Vector4",
        "documentation": "Sets this vector to a + b."
      },
      {
        "name": "addScaledVector",
        "type": "(v: Vector4, s: number) => Vector4"
      },
      {
        "name": "sub",
        "type": "(v: Vector4) => Vector4",
        "documentation": "Subtracts v from this vector."
      },
      {
        "name": "subScalar",
        "type": "(s: number) => Vector4"
      },
      {
        "name": "subVectors",
        "type": "(a: Vector4, b: Vector4) => Vector4",
        "documentation": "Sets this vector to a - b."
      },
      {
        "name": "multiplyScalar",
        "type": "(s: number) => Vector4",
        "documentation": "Multiplies this vector by scalar s."
      },
      {
        "name": "applyMatrix4",
        "type": "(m: Matrix4) => Vector4"
      },
      {
        "name": "divideScalar",
        "type": "(s: number) => Vector4",
        "documentation": "Divides this vector by scalar s.\r\nSet vector to ( 0, 0, 0 ) if s == 0."
      },
      {
        "name": "setAxisAngleFromQuaternion",
        "type": "(q: Quaternion) => Vector4",
        "documentation": "http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm"
      },
      {
        "name": "setAxisAngleFromRotationMatrix",
        "type": "(m: Matrix3) => Vector4",
        "documentation": "http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm"
      },
      {
        "name": "min",
        "type": "(v: Vector4) => Vector4"
      },
      {
        "name": "max",
        "type": "(v: Vector4) => Vector4"
      },
      {
        "name": "clamp",
        "type": "(min: Vector4, max: Vector4) => Vector4"
      },
      {
        "name": "clampScalar",
        "type": "(min: number, max: number) => Vector4"
      },
      {
        "name": "floor",
        "type": "() => Vector4"
      },
      {
        "name": "ceil",
        "type": "() => Vector4"
      },
      {
        "name": "round",
        "type": "() => Vector4"
      },
      {
        "name": "roundToZero",
        "type": "() => Vector4"
      },
      {
        "name": "negate",
        "type": "() => Vector4",
        "documentation": "Inverts this vector."
      },
      {
        "name": "dot",
        "type": "(v: Vector4) => number",
        "documentation": "Computes dot product of this vector and v."
      },
      {
        "name": "lengthSq",
        "type": "() => number",
        "documentation": "Computes squared length of this vector."
      },
      {
        "name": "length",
        "type": "() => number",
        "documentation": "Computes length of this vector."
      },
      {
        "name": "lengthManhattan",
        "type": "() => number"
      },
      {
        "name": "normalize",
        "type": "() => Vector4",
        "documentation": "Normalizes this vector."
      },
      {
        "name": "setLength",
        "type": "(length: number) => Vector4",
        "documentation": "Normalizes this vector and multiplies it by l."
      },
      {
        "name": "lerp",
        "type": "(v: Vector4, alpha: number) => Vector4",
        "documentation": "Linearly interpolate between this vector and v with alpha factor."
      },
      {
        "name": "lerpVectors",
        "type": "(v1: Vector4, v2: Vector4, alpha: number) => Vector4"
      },
      {
        "name": "equals",
        "type": "(v: Vector4) => boolean",
        "documentation": "Checks for strict equality of this vector and v."
      },
      {
        "name": "fromArray",
        "type": "(xyzw: number[], offset?: number) => Vector4"
      },
      {
        "name": "toArray",
        "type": "(xyzw?: number[], offset?: number) => number[]"
      },
      {
        "name": "fromBufferAttribute",
        "type": "(attribute: BufferAttribute, index: number, offset?: number) => Vector4"
      }
    ]
  },
  {
    "name": "Interpolant",
    "type": "typeof Interpolant",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameterPositions",
            "type": "any"
          },
          {
            "name": "samplesValues",
            "type": "any"
          },
          {
            "name": "sampleSize",
            "type": "number"
          },
          {
            "name": "resultBuffer?",
            "type": "any"
          }
        ],
        "returnType": "Interpolant"
      }
    ],
    "properties": [
      {
        "name": "parameterPositions",
        "type": "any"
      },
      {
        "name": "samplesValues",
        "type": "any"
      },
      {
        "name": "valueSize",
        "type": "number"
      },
      {
        "name": "resultBuffer",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "evaluate",
        "type": "(time: number) => any"
      }
    ]
  },
  {
    "name": "CubicInterpolant",
    "type": "typeof CubicInterpolant",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameterPositions",
            "type": "any"
          },
          {
            "name": "samplesValues",
            "type": "any"
          },
          {
            "name": "sampleSize",
            "type": "number"
          },
          {
            "name": "resultBuffer?",
            "type": "any"
          }
        ],
        "returnType": "CubicInterpolant"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "interpolate_",
        "type": "(i1: number, t0: number, t: number, t1: number) => any"
      }
    ]
  },
  {
    "name": "DiscreteInterpolant",
    "type": "typeof DiscreteInterpolant",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameterPositions",
            "type": "any"
          },
          {
            "name": "samplesValues",
            "type": "any"
          },
          {
            "name": "sampleSize",
            "type": "number"
          },
          {
            "name": "resultBuffer?",
            "type": "any"
          }
        ],
        "returnType": "DiscreteInterpolant"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "interpolate_",
        "type": "(i1: number, t0: number, t: number, t1: number) => any"
      }
    ]
  },
  {
    "name": "LinearInterpolant",
    "type": "typeof LinearInterpolant",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameterPositions",
            "type": "any"
          },
          {
            "name": "samplesValues",
            "type": "any"
          },
          {
            "name": "sampleSize",
            "type": "number"
          },
          {
            "name": "resultBuffer?",
            "type": "any"
          }
        ],
        "returnType": "LinearInterpolant"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "interpolate_",
        "type": "(i1: number, t0: number, t: number, t1: number) => any"
      }
    ]
  },
  {
    "name": "QuaternionLinearInterpolant",
    "type": "typeof QuaternionLinearInterpolant",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameterPositions",
            "type": "any"
          },
          {
            "name": "samplesValues",
            "type": "any"
          },
          {
            "name": "sampleSize",
            "type": "number"
          },
          {
            "name": "resultBuffer?",
            "type": "any"
          }
        ],
        "returnType": "QuaternionLinearInterpolant"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "interpolate_",
        "type": "(i1: number, t0: number, t: number, t1: number) => any"
      }
    ]
  },
  {
    "name": "Bone",
    "type": "typeof Bone",
    "constructors": [
      {
        "parameters": [
          {
            "name": "skin",
            "type": "SkinnedMesh"
          }
        ],
        "returnType": "Bone"
      }
    ],
    "properties": [
      {
        "name": "skin",
        "type": "SkinnedMesh"
      }
    ],
    "methods": []
  },
  {
    "name": "Group",
    "type": "typeof Group",
    "constructors": [
      {
        "returnType": "Group"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "LOD",
    "type": "typeof LOD",
    "constructors": [
      {
        "returnType": "LOD"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "levels",
        "type": "any[]"
      },
      {
        "name": "addLevel",
        "type": "(object: Object3D, distance?: number) => void"
      },
      {
        "name": "getObjectForDistance",
        "type": "(distance: number) => Object3D"
      },
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      },
      {
        "name": "update",
        "type": "(camera: Camera) => void"
      },
      {
        "name": "toJSON",
        "type": "(meta: any) => any"
      },
      {
        "name": "objects",
        "type": "any[]"
      }
    ]
  },
  {
    "name": "LensFlareProperty",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "size",
        "type": "number"
      },
      {
        "name": "distance",
        "type": "number"
      },
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "scale",
        "type": "number"
      },
      {
        "name": "rotation",
        "type": "number"
      },
      {
        "name": "opacity",
        "type": "number"
      },
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "blending",
        "type": "Blending"
      }
    ],
    "methods": []
  },
  {
    "name": "LensFlare",
    "type": "typeof LensFlare",
    "constructors": [
      {
        "parameters": [
          {
            "name": "texture?",
            "type": "Texture"
          },
          {
            "name": "size?",
            "type": "number"
          },
          {
            "name": "distance?",
            "type": "number"
          },
          {
            "name": "blending?",
            "type": "Blending"
          },
          {
            "name": "color?",
            "type": "Color"
          }
        ],
        "returnType": "LensFlare"
      }
    ],
    "properties": [
      {
        "name": "positionScreen",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "lensFlares",
        "type": "LensFlareProperty[]"
      },
      {
        "name": "customUpdateCallback",
        "type": "(object: LensFlare) => void"
      },
      {
        "name": "add",
        "type": "{ (object: Object3D): void; (texture: Texture, size?: number, distance?: number, blending?: Blend..."
      },
      {
        "name": "updateLensFlares",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "Line",
    "type": "typeof Line",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "LineBasicMaterial | LineDashedMaterial | ShaderMaterial"
          },
          {
            "name": "mode?",
            "type": "number"
          }
        ],
        "returnType": "Line"
      }
    ],
    "properties": [
      {
        "name": "material",
        "type": "Material"
      }
    ],
    "methods": [
      {
        "name": "geometry",
        "type": "BufferGeometry | Geometry"
      },
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      }
    ]
  },
  {
    "name": "LineSegments",
    "type": "typeof LineSegments",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "LineBasicMaterial | LineDashedMaterial | ShaderMaterial | (LineBasicMaterial | LineDashedMaterial..."
          },
          {
            "name": "mode?",
            "type": "number"
          }
        ],
        "returnType": "LineSegments"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Mesh",
    "type": "typeof Mesh",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "Material | Material[]"
          }
        ],
        "returnType": "Mesh"
      }
    ],
    "properties": [
      {
        "name": "drawMode",
        "type": "TrianglesDrawModes"
      }
    ],
    "methods": [
      {
        "name": "geometry",
        "type": "BufferGeometry | Geometry"
      },
      {
        "name": "material",
        "type": "Material | Material[]"
      },
      {
        "name": "setDrawMode",
        "type": "(drawMode: TrianglesDrawModes) => void"
      },
      {
        "name": "updateMorphTargets",
        "type": "() => void"
      },
      {
        "name": "getMorphTargetIndexByName",
        "type": "(name: string) => number"
      },
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      }
    ]
  },
  {
    "name": "Points",
    "type": "typeof Points",
    "documentation": "A class for displaying particles in the form of variable size points. For example, if using the WebGLRenderer, the particles are displayed using GL_POINTS.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry",
            "documentation": "An instance of Geometry or BufferGeometry."
          },
          {
            "name": "material?",
            "type": "Material",
            "documentation": "An instance of Material (optional)."
          }
        ],
        "returnType": "Points"
      }
    ],
    "properties": [
      {
        "name": "material",
        "type": "Material",
        "documentation": "An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour."
      }
    ],
    "methods": [
      {
        "name": "geometry",
        "type": "BufferGeometry | Geometry",
        "documentation": "An instance of Geometry or BufferGeometry, where each vertex designates the position of a particle in the system."
      },
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      }
    ]
  },
  {
    "name": "PointCloud",
    "type": "typeof PointCloud",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry",
            "documentation": "An instance of Geometry or BufferGeometry."
          },
          {
            "name": "material?",
            "type": "Material",
            "documentation": "An instance of Material (optional)."
          }
        ],
        "returnType": "PointCloud"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ParticleSystem",
    "type": "typeof ParticleSystem",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry",
            "documentation": "An instance of Geometry or BufferGeometry."
          },
          {
            "name": "material?",
            "type": "Material",
            "documentation": "An instance of Material (optional)."
          }
        ],
        "returnType": "ParticleSystem"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Skeleton",
    "type": "typeof Skeleton",
    "constructors": [
      {
        "parameters": [
          {
            "name": "bones",
            "type": "Bone[]"
          },
          {
            "name": "boneInverses?",
            "type": "Matrix4[]"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "Skeleton"
      }
    ],
    "properties": [
      {
        "name": "useVertexTexture",
        "type": "boolean"
      },
      {
        "name": "identityMatrix",
        "type": "Matrix4"
      },
      {
        "name": "boneTextureWidth",
        "type": "number"
      },
      {
        "name": "boneTextureHeight",
        "type": "number"
      },
      {
        "name": "boneMatrices",
        "type": "Float32Array"
      },
      {
        "name": "boneTexture",
        "type": "DataTexture"
      }
    ],
    "methods": [
      {
        "name": "bones",
        "type": "Bone[]"
      },
      {
        "name": "boneInverses",
        "type": "Matrix4[]"
      },
      {
        "name": "calculateInverses",
        "type": "(bone: Bone) => void"
      },
      {
        "name": "pose",
        "type": "() => void"
      },
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "clone",
        "type": "() => this"
      }
    ]
  },
  {
    "name": "SkinnedMesh",
    "type": "typeof SkinnedMesh",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MeshBasicMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MeshDepthMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MultiMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MeshLambertMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MeshNormalMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "MeshPhongMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      },
      {
        "parameters": [
          {
            "name": "geometry?",
            "type": "BufferGeometry | Geometry"
          },
          {
            "name": "material?",
            "type": "ShaderMaterial"
          },
          {
            "name": "useVertexTexture?",
            "type": "boolean"
          }
        ],
        "returnType": "SkinnedMesh"
      }
    ],
    "properties": [
      {
        "name": "bindMode",
        "type": "string"
      },
      {
        "name": "bindMatrix",
        "type": "Matrix4"
      },
      {
        "name": "bindMatrixInverse",
        "type": "Matrix4"
      },
      {
        "name": "skeleton",
        "type": "Skeleton"
      }
    ],
    "methods": [
      {
        "name": "bind",
        "type": "(skeleton: Skeleton, bindMatrix?: Matrix4) => void"
      },
      {
        "name": "pose",
        "type": "() => void"
      },
      {
        "name": "normalizeSkinWeights",
        "type": "() => void"
      },
      {
        "name": "updateMatrixWorld",
        "type": "(force?: boolean) => void"
      }
    ]
  },
  {
    "name": "Sprite",
    "type": "typeof Sprite",
    "constructors": [
      {
        "parameters": [
          {
            "name": "material?",
            "type": "Material"
          }
        ],
        "returnType": "Sprite"
      }
    ],
    "properties": [
      {
        "name": "geometry",
        "type": "BufferGeometry"
      },
      {
        "name": "material",
        "type": "SpriteMaterial"
      }
    ],
    "methods": [
      {
        "name": "raycast",
        "type": "(raycaster: Raycaster, intersects: any) => void"
      }
    ]
  },
  {
    "name": "Particle",
    "type": "typeof Particle",
    "constructors": [
      {
        "parameters": [
          {
            "name": "material?",
            "type": "Material"
          }
        ],
        "returnType": "Particle"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Renderer",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera) => void"
      },
      {
        "name": "setSize",
        "type": "(width: number, height: number, updateStyle?: boolean) => void"
      }
    ]
  },
  {
    "name": "WebGLRendererParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "precision?",
        "type": "string",
        "documentation": "shader precision. Can be \"highp\", \"mediump\" or \"lowp\"."
      },
      {
        "name": "alpha?",
        "type": "boolean",
        "documentation": "default is true."
      },
      {
        "name": "premultipliedAlpha?",
        "type": "boolean",
        "documentation": "default is true."
      },
      {
        "name": "antialias?",
        "type": "boolean",
        "documentation": "default is false."
      },
      {
        "name": "stencil?",
        "type": "boolean",
        "documentation": "default is true."
      },
      {
        "name": "preserveDrawingBuffer?",
        "type": "boolean",
        "documentation": "default is false."
      },
      {
        "name": "clearColor?",
        "type": "number",
        "documentation": "default is 0x000000."
      },
      {
        "name": "clearAlpha?",
        "type": "number",
        "documentation": "default is 0."
      },
      {
        "name": "devicePixelRatio?",
        "type": "number"
      },
      {
        "name": "logarithmicDepthBuffer?",
        "type": "boolean",
        "documentation": "default is false."
      }
    ],
    "methods": []
  },
  {
    "name": "WebGLRenderer",
    "type": "typeof WebGLRenderer",
    "documentation": "The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.\r\nThis renderer has way better performance than CanvasRenderer.",
    "constructors": [
      {
        "documentation": "parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.",
        "parameters": [
          {
            "name": "parameters?",
            "type": "WebGLRendererParameters"
          }
        ],
        "returnType": "WebGLRenderer"
      }
    ],
    "properties": [
      {
        "name": "domElement",
        "type": "HTMLCanvasElement",
        "documentation": "A Canvas where the renderer draws its output.\r\nThis is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page."
      },
      {
        "name": "context",
        "type": "WebGLRenderingContext",
        "documentation": "The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw."
      },
      {
        "name": "autoClear",
        "type": "boolean",
        "documentation": "Defines whether the renderer should automatically clear its output before rendering."
      },
      {
        "name": "autoClearColor",
        "type": "boolean",
        "documentation": "If autoClear is true, defines whether the renderer should clear the color buffer. Default is true."
      },
      {
        "name": "autoClearDepth",
        "type": "boolean",
        "documentation": "If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true."
      },
      {
        "name": "autoClearStencil",
        "type": "boolean",
        "documentation": "If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true."
      },
      {
        "name": "sortObjects",
        "type": "boolean",
        "documentation": "Defines whether the renderer should sort objects. Default is true."
      },
      {
        "name": "localClippingEnabled",
        "type": "boolean"
      },
      {
        "name": "extensions",
        "type": "WebGLExtensions"
      },
      {
        "name": "gammaInput",
        "type": "boolean",
        "documentation": "Default is false."
      },
      {
        "name": "gammaOutput",
        "type": "boolean",
        "documentation": "Default is false."
      },
      {
        "name": "physicallyCorrectLights",
        "type": "boolean"
      },
      {
        "name": "toneMapping",
        "type": "ToneMapping"
      },
      {
        "name": "toneMappingExposure",
        "type": "number"
      },
      {
        "name": "toneMappingWhitePoint",
        "type": "number"
      },
      {
        "name": "shadowMapDebug",
        "type": "boolean",
        "documentation": "Default is false."
      },
      {
        "name": "maxMorphTargets",
        "type": "number",
        "documentation": "Default is 8."
      },
      {
        "name": "maxMorphNormals",
        "type": "number",
        "documentation": "Default is 4."
      },
      {
        "name": "shadowMap",
        "type": "WebGLShadowMap"
      },
      {
        "name": "pixelRation",
        "type": "number"
      },
      {
        "name": "capabilities",
        "type": "WebGLCapabilities"
      },
      {
        "name": "properties",
        "type": "WebGLProperties"
      },
      {
        "name": "renderLists",
        "type": "WebGLRenderLists"
      },
      {
        "name": "state",
        "type": "WebGLState"
      },
      {
        "name": "allocTextureUnit",
        "type": "any"
      },
      {
        "name": "gammaFactor",
        "type": "number"
      },
      {
        "name": "shadowMapEnabled",
        "type": "boolean"
      },
      {
        "name": "shadowMapType",
        "type": "ShadowMapType"
      },
      {
        "name": "shadowMapCullFace",
        "type": "CullFace"
      }
    ],
    "methods": [
      {
        "name": "clippingPlanes",
        "type": "any[]"
      },
      {
        "name": "info",
        "type": "{ memory: { geometries: number; textures: number; }; render: { calls: number; vertices: number; f...",
        "documentation": "An object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:"
      },
      {
        "name": "getContext",
        "type": "() => WebGLRenderingContext",
        "documentation": "Return the WebGL context."
      },
      {
        "name": "getContextAttributes",
        "type": "() => any"
      },
      {
        "name": "forceContextLoss",
        "type": "() => void"
      },
      {
        "name": "getMaxAnisotropy",
        "type": "() => number"
      },
      {
        "name": "getPrecision",
        "type": "() => string"
      },
      {
        "name": "getPixelRatio",
        "type": "() => number"
      },
      {
        "name": "setPixelRatio",
        "type": "(value: number) => void"
      },
      {
        "name": "getSize",
        "type": "() => { width: number; height: number; }"
      },
      {
        "name": "setSize",
        "type": "(width: number, height: number, updateStyle?: boolean) => void",
        "documentation": "Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0)."
      },
      {
        "name": "setViewport",
        "type": "(x?: number, y?: number, width?: number, height?: number) => void",
        "documentation": "Sets the viewport to render from (x, y) to (x + width, y + height)."
      },
      {
        "name": "setScissor",
        "type": "(x: number, y: number, width: number, height: number) => void",
        "documentation": "Sets the scissor area from (x, y) to (x + width, y + height)."
      },
      {
        "name": "setScissorTest",
        "type": "(enable: boolean) => void",
        "documentation": "Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions."
      },
      {
        "name": "getClearColor",
        "type": "() => Color",
        "documentation": "Returns a THREE.Color instance with the current clear color."
      },
      {
        "name": "setClearColor",
        "type": "{ (color: Color, alpha?: number): void; (color: string, alpha?: number): void; (color: number, al...",
        "documentation": "Sets the clear color, using color for the color and alpha for the opacity."
      },
      {
        "name": "getClearAlpha",
        "type": "() => number",
        "documentation": "Returns a float with the current clear alpha. Ranges from 0 to 1."
      },
      {
        "name": "setClearAlpha",
        "type": "(alpha: number) => void"
      },
      {
        "name": "clear",
        "type": "(color?: boolean, depth?: boolean, stencil?: boolean) => void",
        "documentation": "Tells the renderer to clear its color, depth or stencil drawing buffer(s).\r\nArguments default to true"
      },
      {
        "name": "clearColor",
        "type": "() => void"
      },
      {
        "name": "clearDepth",
        "type": "() => void"
      },
      {
        "name": "clearStencil",
        "type": "() => void"
      },
      {
        "name": "clearTarget",
        "type": "(renderTarget: WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean) => void"
      },
      {
        "name": "resetGLState",
        "type": "() => void"
      },
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "renderBufferImmediate",
        "type": "(object: Object3D, program: Object, material: Material) => void",
        "documentation": "Tells the shadow map plugin to update using the passed scene and camera parameters."
      },
      {
        "name": "renderBufferDirect",
        "type": "(camera: Camera, fog: Fog, material: Material, geometryGroup: any, object: Object3D) => void"
      },
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera, renderTarget?: RenderTarget, forceClear?: boolean) => void",
        "documentation": "Render a scene using a camera.\r\nThe render is done to the renderTarget (if specified) or to the canvas as usual.\r\nIf forceClear is true, the canvas will be cleared before rendering, even if the renderer's autoClear property is false."
      },
      {
        "name": "setFaceCulling",
        "type": "(cullFace?: CullFace, frontFace?: FrontFaceDirection) => void",
        "documentation": "Used for setting the gl frontFace, cullFace states in the GPU, thus enabling/disabling face culling when rendering.\r\nIf cullFace is false, culling will be disabled."
      },
      {
        "name": "setTexture",
        "type": "(texture: Texture, slot: number) => void"
      },
      {
        "name": "setTexture2D",
        "type": "(texture: Texture, slot: number) => void"
      },
      {
        "name": "setTextureCube",
        "type": "(texture: Texture, slot: number) => void"
      },
      {
        "name": "getCurrentRenderTarget",
        "type": "() => RenderTarget"
      },
      {
        "name": "setRenderTarget",
        "type": "(renderTarget: RenderTarget) => void"
      },
      {
        "name": "readRenderTargetPixels",
        "type": "(renderTarget: RenderTarget, x: number, y: number, width: number, height: number, buffer: any) =>..."
      },
      {
        "name": "supportsFloatTextures",
        "type": "() => any"
      },
      {
        "name": "supportsHalfFloatTextures",
        "type": "() => any"
      },
      {
        "name": "supportsStandardDerivatives",
        "type": "() => any"
      },
      {
        "name": "supportsCompressedTextureS3TC",
        "type": "() => any"
      },
      {
        "name": "supportsCompressedTexturePVRTC",
        "type": "() => any"
      },
      {
        "name": "supportsBlendMinMax",
        "type": "() => any"
      },
      {
        "name": "supportsVertexTextures",
        "type": "() => any"
      },
      {
        "name": "supportsInstancedArrays",
        "type": "() => any"
      },
      {
        "name": "enableScissorTest",
        "type": "(boolean: any) => any"
      }
    ]
  },
  {
    "name": "RenderTarget",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": []
  },
  {
    "name": "RenderItem",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      },
      {
        "name": "material",
        "type": "Material"
      },
      {
        "name": "program",
        "type": "WebGLProgram"
      },
      {
        "name": "renderOrder",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "group",
        "type": "Group"
      }
    ],
    "methods": [
      {
        "name": "geometry",
        "type": "BufferGeometry | Geometry"
      }
    ]
  },
  {
    "name": "WebGLRenderList",
    "type": "typeof WebGLRenderList",
    "constructors": [
      {
        "returnType": "WebGLRenderList"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "transparent",
        "type": "any[]"
      },
      {
        "name": "init",
        "type": "() => void"
      },
      {
        "name": "push",
        "type": "(object: Object3D, geometry: BufferGeometry | Geometry, material: Material, z: number, group: Gro..."
      },
      {
        "name": "sort",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLRenderLists",
    "type": "typeof WebGLRenderLists",
    "constructors": [
      {
        "returnType": "WebGLRenderLists"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "get",
        "type": "(scene: Scene, camera: Camera) => WebGLRenderList",
        "documentation": "returns {<String> : <WebGLRenderList>}"
      }
    ]
  },
  {
    "name": "WebGLRenderTargetOptions",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "wrapT?",
        "type": "Wrapping"
      },
      {
        "name": "magFilter?",
        "type": "TextureFilter"
      },
      {
        "name": "minFilter?",
        "type": "TextureFilter"
      },
      {
        "name": "format?",
        "type": "number"
      },
      {
        "name": "type?",
        "type": "TextureDataType"
      },
      {
        "name": "anisotropy?",
        "type": "number"
      },
      {
        "name": "depthBuffer?",
        "type": "boolean"
      },
      {
        "name": "stencilBuffer?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "WebGLRenderTarget",
    "type": "typeof WebGLRenderTarget",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "options?",
            "type": "WebGLRenderTargetOptions"
          }
        ],
        "returnType": "WebGLRenderTarget"
      }
    ],
    "properties": [
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "width",
        "type": "number"
      },
      {
        "name": "height",
        "type": "number"
      },
      {
        "name": "scissor",
        "type": "Vector4"
      },
      {
        "name": "scissorTest",
        "type": "boolean"
      },
      {
        "name": "viewport",
        "type": "Vector4"
      },
      {
        "name": "texture",
        "type": "Texture"
      },
      {
        "name": "depthBuffer",
        "type": "boolean"
      },
      {
        "name": "stencilBuffer",
        "type": "boolean"
      },
      {
        "name": "depthTexture",
        "type": "Texture"
      },
      {
        "name": "wrapS",
        "type": "any"
      },
      {
        "name": "wrapT",
        "type": "any"
      },
      {
        "name": "magFilter",
        "type": "any"
      },
      {
        "name": "minFilter",
        "type": "any"
      },
      {
        "name": "anisotropy",
        "type": "any"
      },
      {
        "name": "offset",
        "type": "any"
      },
      {
        "name": "repeat",
        "type": "any"
      },
      {
        "name": "format",
        "type": "any"
      },
      {
        "name": "type",
        "type": "any"
      },
      {
        "name": "generateMipmaps",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "setSize",
        "type": "(width: number, height: number) => void"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "dispose",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLRenderTargetCube",
    "type": "typeof WebGLRenderTargetCube",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "options?",
            "type": "WebGLRenderTargetOptions"
          }
        ],
        "returnType": "WebGLRenderTargetCube"
      }
    ],
    "properties": [
      {
        "name": "activeCubeFace",
        "type": "number"
      },
      {
        "name": "activeMipMapLevel",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "Shader",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "vertexShader",
        "type": "string"
      },
      {
        "name": "fragmentShader",
        "type": "string"
      }
    ],
    "methods": []
  },
  {
    "name": "IUniform",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": []
  },
  {
    "name": "Uniform",
    "type": "typeof Uniform",
    "constructors": [
      {
        "parameters": [
          {
            "name": "value",
            "type": "any"
          }
        ],
        "returnType": "Uniform"
      },
      {
        "parameters": [
          {
            "name": "type",
            "type": "string"
          },
          {
            "name": "value",
            "type": "any"
          }
        ],
        "returnType": "Uniform"
      }
    ],
    "properties": [
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "value",
        "type": "any"
      },
      {
        "name": "dynamic",
        "type": "boolean"
      },
      {
        "name": "onUpdateCallback",
        "type": "Function"
      }
    ],
    "methods": [
      {
        "name": "onUpdate",
        "type": "(callback: Function) => Uniform"
      }
    ]
  },
  {
    "name": "WebGLBufferRenderer",
    "type": "typeof WebGLBufferRenderer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "_gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "extensions",
            "type": "any"
          },
          {
            "name": "_infoRender",
            "type": "any"
          }
        ],
        "returnType": "WebGLBufferRenderer"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setMode",
        "type": "(value: any) => void"
      },
      {
        "name": "render",
        "type": "(start: any, count: number) => void"
      },
      {
        "name": "renderInstances",
        "type": "(geometry: any) => void"
      }
    ]
  },
  {
    "name": "WebGLClipping",
    "type": "typeof WebGLClipping",
    "constructors": [
      {
        "returnType": "WebGLClipping"
      }
    ],
    "properties": [
      {
        "name": "numPlanes",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "init",
        "type": "(planes: any[], enableLocalClipping: boolean, camera: Camera) => boolean"
      },
      {
        "name": "beginShadows",
        "type": "() => void"
      },
      {
        "name": "endShadows",
        "type": "() => void"
      },
      {
        "name": "setState",
        "type": "(planes: any[], clipShadows: boolean, camera: Camera, cache: boolean, fromCache: boolean) => void"
      }
    ]
  },
  {
    "name": "WebGLCapabilitiesParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "logarithmicDepthBuffer?",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "WebGLCapabilities",
    "type": "typeof WebGLCapabilities",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "extensions",
            "type": "any"
          },
          {
            "name": "parameters",
            "type": "WebGLCapabilitiesParameters"
          }
        ],
        "returnType": "WebGLCapabilities"
      }
    ],
    "properties": [
      {
        "name": "precision",
        "type": "any"
      },
      {
        "name": "logarithmicDepthBuffer",
        "type": "any"
      },
      {
        "name": "maxTextures",
        "type": "any"
      },
      {
        "name": "maxVertexTextures",
        "type": "any"
      },
      {
        "name": "maxTextureSize",
        "type": "any"
      },
      {
        "name": "maxCubemapSize",
        "type": "any"
      },
      {
        "name": "maxAttributes",
        "type": "any"
      },
      {
        "name": "maxVertexUniforms",
        "type": "any"
      },
      {
        "name": "maxVaryings",
        "type": "any"
      },
      {
        "name": "maxFragmentUniforms",
        "type": "any"
      },
      {
        "name": "vertexTextures",
        "type": "any"
      },
      {
        "name": "floatFragmentTextures",
        "type": "any"
      },
      {
        "name": "floatVertexTextures",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "getMaxAnisotropy",
        "type": "() => number"
      },
      {
        "name": "getMaxPrecision",
        "type": "(precision: string) => string"
      }
    ]
  },
  {
    "name": "WebGLExtensions",
    "type": "typeof WebGLExtensions",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          }
        ],
        "returnType": "WebGLExtensions"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "get",
        "type": "(name: string) => any"
      }
    ]
  },
  {
    "name": "WebGLGeometries",
    "type": "typeof WebGLGeometries",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "extensions",
            "type": "any"
          },
          {
            "name": "_infoRender",
            "type": "any"
          }
        ],
        "returnType": "WebGLGeometries"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "get",
        "type": "(object: any) => any"
      }
    ]
  },
  {
    "name": "WebGLLights",
    "type": "typeof WebGLLights",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "properties",
            "type": "any"
          },
          {
            "name": "info",
            "type": "any"
          }
        ],
        "returnType": "WebGLLights"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "get",
        "type": "(light: any) => any"
      }
    ]
  },
  {
    "name": "WebGLIndexedBufferRenderer",
    "type": "typeof WebGLIndexedBufferRenderer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "properties",
            "type": "any"
          },
          {
            "name": "info",
            "type": "any"
          }
        ],
        "returnType": "WebGLIndexedBufferRenderer"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setMode",
        "type": "(value: any) => void"
      },
      {
        "name": "setIndex",
        "type": "(index: any) => void"
      },
      {
        "name": "render",
        "type": "(start: any, count: number) => void"
      },
      {
        "name": "renderInstances",
        "type": "(geometry: any, start: any, count: number) => void"
      }
    ]
  },
  {
    "name": "WebGLObjects",
    "type": "typeof WebGLObjects",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "WebGLRenderingContext"
          },
          {
            "name": "properties",
            "type": "any"
          },
          {
            "name": "info",
            "type": "any"
          }
        ],
        "returnType": "WebGLObjects"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "getAttributeBuffer",
        "type": "(attribute: any) => any"
      },
      {
        "name": "getWireframeAttribute",
        "type": "(geometry: any) => any"
      },
      {
        "name": "update",
        "type": "(object: any) => void"
      }
    ]
  },
  {
    "name": "WebGLProgram",
    "type": "typeof WebGLProgram",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          },
          {
            "name": "code",
            "type": "string"
          },
          {
            "name": "material",
            "type": "ShaderMaterial"
          },
          {
            "name": "parameters",
            "type": "WebGLRendererParameters"
          }
        ],
        "returnType": "WebGLProgram"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "code",
        "type": "string"
      },
      {
        "name": "usedTimes",
        "type": "number"
      },
      {
        "name": "program",
        "type": "any"
      },
      {
        "name": "vertexShader",
        "type": "WebGLShader"
      },
      {
        "name": "fragmentShader",
        "type": "WebGLShader"
      },
      {
        "name": "uniforms",
        "type": "any"
      },
      {
        "name": "attributes",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "getUniforms",
        "type": "() => WebGLUniforms"
      },
      {
        "name": "getAttributes",
        "type": "() => any"
      },
      {
        "name": "destroy",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLPrograms",
    "type": "typeof WebGLPrograms",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          },
          {
            "name": "capabilities",
            "type": "any"
          }
        ],
        "returnType": "WebGLPrograms"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "programs",
        "type": "any[]"
      },
      {
        "name": "getParameters",
        "type": "(material: ShaderMaterial, lights: any, fog: any, nClipPlanes: number, object: any) => any"
      },
      {
        "name": "getProgramCode",
        "type": "(material: ShaderMaterial, parameters: any) => string"
      },
      {
        "name": "acquireProgram",
        "type": "(material: ShaderMaterial, parameters: any, code: string) => WebGLProgram"
      },
      {
        "name": "releaseProgram",
        "type": "(program: WebGLProgram) => void"
      }
    ]
  },
  {
    "name": "WebGLTextures",
    "type": "typeof WebGLTextures",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "extensions",
            "type": "any"
          },
          {
            "name": "state",
            "type": "any"
          },
          {
            "name": "properties",
            "type": "any"
          },
          {
            "name": "capabilities",
            "type": "any"
          },
          {
            "name": "paramThreeToGL",
            "type": "Function"
          },
          {
            "name": "info",
            "type": "any"
          }
        ],
        "returnType": "WebGLTextures"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setTexture2D",
        "type": "(texture: any, slot: number) => void"
      },
      {
        "name": "setTextureCube",
        "type": "(texture: any, slot: number) => void"
      },
      {
        "name": "setTextureCubeDynamic",
        "type": "(texture: any, slot: number) => void"
      },
      {
        "name": "setupRenderTarget",
        "type": "(renderTarget: any) => void"
      },
      {
        "name": "updateRenderTargetMipmap",
        "type": "(renderTarget: any) => void"
      }
    ]
  },
  {
    "name": "WebGLUniforms",
    "type": "typeof WebGLUniforms",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "program",
            "type": "WebGLProgram"
          },
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          }
        ],
        "returnType": "WebGLUniforms"
      }
    ],
    "properties": [
      {
        "name": "renderer",
        "type": "WebGLRenderer"
      }
    ],
    "methods": [
      {
        "name": "setValue",
        "type": "(gl: any, value: any, renderer?: any) => void"
      },
      {
        "name": "set",
        "type": "(gl: any, object: any, name: string) => void"
      },
      {
        "name": "setOptional",
        "type": "(gl: any, object: any, name: string) => void"
      }
    ]
  },
  {
    "name": "WebGLProperties",
    "type": "typeof WebGLProperties",
    "constructors": [
      {
        "returnType": "WebGLProperties"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "get",
        "type": "(object: any) => any"
      },
      {
        "name": "delete",
        "type": "(object: any) => void"
      },
      {
        "name": "clear",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLShader",
    "type": "typeof WebGLShader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "type",
            "type": "string"
          },
          {
            "name": "string",
            "type": "string"
          }
        ],
        "returnType": "WebGLShader"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "WebGLShadowMap",
    "type": "typeof WebGLShadowMap",
    "constructors": [
      {
        "parameters": [
          {
            "name": "_renderer",
            "type": "Renderer"
          },
          {
            "name": "_lights",
            "type": "any[]"
          },
          {
            "name": "_objects",
            "type": "any[]"
          },
          {
            "name": "capabilities",
            "type": "any"
          }
        ],
        "returnType": "WebGLShadowMap"
      }
    ],
    "properties": [
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "autoUpdate",
        "type": "boolean"
      },
      {
        "name": "needsUpdate",
        "type": "boolean"
      },
      {
        "name": "type",
        "type": "ShadowMapType"
      },
      {
        "name": "renderReverseSided",
        "type": "boolean"
      },
      {
        "name": "renderSingleSided",
        "type": "boolean"
      },
      {
        "name": "cullFace",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera) => void"
      }
    ]
  },
  {
    "name": "WebGLState",
    "type": "typeof WebGLState",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "extensions",
            "type": "any"
          },
          {
            "name": "paramThreeToGL",
            "type": "Function"
          }
        ],
        "returnType": "WebGLState"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "buffers",
        "type": "{ color: WebGLColorBuffer; depth: WebGLDepthBuffer; stencil: WebGLStencilBuffer; }"
      },
      {
        "name": "init",
        "type": "() => void"
      },
      {
        "name": "initAttributes",
        "type": "() => void"
      },
      {
        "name": "enableAttribute",
        "type": "(attribute: string) => void"
      },
      {
        "name": "enableAttributeAndDivisor",
        "type": "(attribute: string, meshPerAttribute: any, extension: any) => void"
      },
      {
        "name": "disableUnusedAttributes",
        "type": "() => void"
      },
      {
        "name": "enable",
        "type": "(id: string) => void"
      },
      {
        "name": "disable",
        "type": "(id: string) => void"
      },
      {
        "name": "getCompressedTextureFormats",
        "type": "() => any[]"
      },
      {
        "name": "setBlending",
        "type": "(blending: number, blendEquation: number, blendSrc: number, blendDst: number, blendEquationAlpha:..."
      },
      {
        "name": "setColorWrite",
        "type": "(colorWrite: number) => void"
      },
      {
        "name": "setDepthTest",
        "type": "(depthTest: number) => void"
      },
      {
        "name": "setDepthWrite",
        "type": "(depthWrite: number) => void"
      },
      {
        "name": "setDepthFunc",
        "type": "(depthFunc: Function) => void"
      },
      {
        "name": "setStencilTest",
        "type": "(stencilTest: boolean) => void"
      },
      {
        "name": "setStencilWrite",
        "type": "(stencilWrite: any) => void"
      },
      {
        "name": "setStencilFunc",
        "type": "(stencilFunc: Function, stencilRef: any, stencilMask: number) => void"
      },
      {
        "name": "setStencilOp",
        "type": "(stencilFail: any, stencilZFail: any, stencilZPass: any) => void"
      },
      {
        "name": "setFlipSided",
        "type": "(flipSided: number) => void"
      },
      {
        "name": "setCullFace",
        "type": "(cullFace: CullFace) => void"
      },
      {
        "name": "setLineWidth",
        "type": "(width: number) => void"
      },
      {
        "name": "setPolygonOffset",
        "type": "(polygonoffset: number, factor: number, units: number) => void"
      },
      {
        "name": "setScissorTest",
        "type": "(scissorTest: boolean) => void"
      },
      {
        "name": "getScissorTest",
        "type": "() => boolean"
      },
      {
        "name": "activeTexture",
        "type": "(webglSlot: any) => void"
      },
      {
        "name": "bindTexture",
        "type": "(webglType: any, webglTexture: any) => void"
      },
      {
        "name": "compressedTexImage2D",
        "type": "() => void"
      },
      {
        "name": "texImage2D",
        "type": "() => void"
      },
      {
        "name": "clearColor",
        "type": "(r: number, g: number, b: number, a: number) => void"
      },
      {
        "name": "clearDepth",
        "type": "(depth: number) => void"
      },
      {
        "name": "clearStencil",
        "type": "(stencil: any) => void"
      },
      {
        "name": "scissor",
        "type": "(scissor: any) => void"
      },
      {
        "name": "viewport",
        "type": "(viewport: any) => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLColorBuffer",
    "type": "typeof WebGLColorBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "state",
            "type": "any"
          }
        ],
        "returnType": "WebGLColorBuffer"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setMask",
        "type": "(colorMask: number) => void"
      },
      {
        "name": "setLocked",
        "type": "(lock: boolean) => void"
      },
      {
        "name": "setClear",
        "type": "(r: number, g: number, b: number, a: number) => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLDepthBuffer",
    "type": "typeof WebGLDepthBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "state",
            "type": "any"
          }
        ],
        "returnType": "WebGLDepthBuffer"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setTest",
        "type": "(depthTest: boolean) => void"
      },
      {
        "name": "sertMask",
        "type": "(depthMask: number) => void"
      },
      {
        "name": "setFunc",
        "type": "(depthFunc: Function) => void"
      },
      {
        "name": "setLocked",
        "type": "(lock: boolean) => void"
      },
      {
        "name": "setClear",
        "type": "(depth: any) => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "WebGLStencilBuffer",
    "type": "typeof WebGLStencilBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "gl",
            "type": "any"
          },
          {
            "name": "state",
            "type": "any"
          }
        ],
        "returnType": "WebGLStencilBuffer"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setTest",
        "type": "(stencilTest: boolean) => void"
      },
      {
        "name": "sertMask",
        "type": "(stencilMask: number) => void"
      },
      {
        "name": "setFunc",
        "type": "(stencilFunc: Function, stencilRef: any, stencilMask: number) => void"
      },
      {
        "name": "setOp",
        "type": "(stencilFail: any, stencilZFail: any, stencilZPass: any) => void"
      },
      {
        "name": "setLocked",
        "type": "(lock: boolean) => void"
      },
      {
        "name": "setClear",
        "type": "(stencil: any) => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "LensFlarePlugin",
    "type": "typeof LensFlarePlugin",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          },
          {
            "name": "flares",
            "type": "any[]"
          }
        ],
        "returnType": "LensFlarePlugin"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera, viewportWidth: number, viewportHeight: number) => void"
      }
    ]
  },
  {
    "name": "SpritePlugin",
    "type": "typeof SpritePlugin",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          },
          {
            "name": "sprites",
            "type": "any[]"
          }
        ],
        "returnType": "SpritePlugin"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera, viewportWidth: number, viewportHeight: number) => void"
      }
    ]
  },
  {
    "name": "Scene",
    "type": "typeof Scene",
    "documentation": "Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.",
    "constructors": [
      {
        "returnType": "Scene"
      }
    ],
    "properties": [
      {
        "name": "fog",
        "type": "IFog",
        "documentation": "A fog instance defining the type of fog that affects everything rendered in the scene. Default is null."
      },
      {
        "name": "overrideMaterial",
        "type": "Material",
        "documentation": "If not null, it will force everything in the scene to be rendered with that material. Default is null."
      },
      {
        "name": "autoUpdate",
        "type": "boolean"
      },
      {
        "name": "background",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "toJSON",
        "type": "(meta?: any) => any"
      }
    ]
  },
  {
    "name": "IFog",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      }
    ],
    "methods": [
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "Fog",
    "type": "typeof Fog",
    "documentation": "This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex",
            "type": "number"
          },
          {
            "name": "near?",
            "type": "number"
          },
          {
            "name": "far?",
            "type": "number"
          }
        ],
        "returnType": "Fog"
      }
    ],
    "properties": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "color",
        "type": "Color",
        "documentation": "Fog color."
      },
      {
        "name": "near",
        "type": "number",
        "documentation": "The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog."
      },
      {
        "name": "far",
        "type": "number",
        "documentation": "The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.\r\nDefault is 1000."
      }
    ],
    "methods": [
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "FogExp2",
    "type": "typeof FogExp2",
    "documentation": "This class contains the parameters that define linear fog, i.e., that grows exponentially denser with the distance.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "hex",
            "type": "string | number"
          },
          {
            "name": "density?",
            "type": "number"
          }
        ],
        "returnType": "FogExp2"
      }
    ],
    "properties": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "density",
        "type": "number",
        "documentation": "Defines how fast the fog will grow dense.\r\nDefault is 0.00025."
      }
    ],
    "methods": [
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "toJSON",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "Texture",
    "type": "typeof Texture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "image?",
            "type": "HTMLImageElement | HTMLCanvasElement | HTMLVideoElement"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          },
          {
            "name": "encoding?",
            "type": "TextureEncoding"
          }
        ],
        "returnType": "Texture"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "uuid",
        "type": "string"
      },
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "sourceFile",
        "type": "string"
      },
      {
        "name": "image",
        "type": "any"
      },
      {
        "name": "mapping",
        "type": "Mapping"
      },
      {
        "name": "wrapS",
        "type": "Wrapping"
      },
      {
        "name": "wrapT",
        "type": "Wrapping"
      },
      {
        "name": "magFilter",
        "type": "TextureFilter"
      },
      {
        "name": "minFilter",
        "type": "TextureFilter"
      },
      {
        "name": "anisotropy",
        "type": "number"
      },
      {
        "name": "format",
        "type": "PixelFormat"
      },
      {
        "name": "type",
        "type": "TextureDataType"
      },
      {
        "name": "offset",
        "type": "Vector2"
      },
      {
        "name": "repeat",
        "type": "Vector2"
      },
      {
        "name": "generateMipmaps",
        "type": "boolean"
      },
      {
        "name": "premultiplyAlpha",
        "type": "boolean"
      },
      {
        "name": "flipY",
        "type": "boolean"
      },
      {
        "name": "unpackAlignment",
        "type": "number"
      },
      {
        "name": "encoding",
        "type": "TextureEncoding"
      },
      {
        "name": "version",
        "type": "number"
      },
      {
        "name": "needsUpdate",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "mipmaps",
        "type": "ImageData[]"
      },
      {
        "name": "onUpdate",
        "type": "() => void"
      },
      {
        "name": "clone",
        "type": "() => this"
      },
      {
        "name": "copy",
        "type": "(source: this) => this"
      },
      {
        "name": "toJSON",
        "type": "(meta: any) => any"
      },
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "transformUv",
        "type": "(uv: Vector) => void"
      }
    ]
  },
  {
    "name": "DepthTexture",
    "type": "typeof DepthTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "heighht",
            "type": "number"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          }
        ],
        "returnType": "DepthTexture"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "image",
        "type": "{ width: number; height: number; }"
      }
    ]
  },
  {
    "name": "CanvasTexture",
    "type": "typeof CanvasTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "canvas",
            "type": "HTMLImageElement | HTMLCanvasElement | HTMLVideoElement"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          }
        ],
        "returnType": "CanvasTexture"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "CubeTexture",
    "type": "typeof CubeTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "images?",
            "type": "any[]"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          },
          {
            "name": "encoding?",
            "type": "TextureEncoding"
          }
        ],
        "returnType": "CubeTexture"
      }
    ],
    "properties": [
      {
        "name": "images",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "CompressedTexture",
    "type": "typeof CompressedTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "mipmaps",
            "type": "ImageData[]"
          },
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          },
          {
            "name": "encoding?",
            "type": "TextureEncoding"
          }
        ],
        "returnType": "CompressedTexture"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "image",
        "type": "{ width: number; height: number; }"
      }
    ]
  },
  {
    "name": "DataTexture",
    "type": "typeof DataTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "data",
            "type": "Float32Array | ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Arra..."
          },
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          },
          {
            "name": "encoding?",
            "type": "TextureEncoding"
          }
        ],
        "returnType": "DataTexture"
      }
    ],
    "properties": [
      {
        "name": "image",
        "type": "ImageData"
      }
    ],
    "methods": []
  },
  {
    "name": "VideoTexture",
    "type": "typeof VideoTexture",
    "constructors": [
      {
        "parameters": [
          {
            "name": "video",
            "type": "HTMLVideoElement"
          },
          {
            "name": "mapping?",
            "type": "Mapping"
          },
          {
            "name": "wrapS?",
            "type": "Wrapping"
          },
          {
            "name": "wrapT?",
            "type": "Wrapping"
          },
          {
            "name": "magFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "minFilter?",
            "type": "TextureFilter"
          },
          {
            "name": "format?",
            "type": "PixelFormat"
          },
          {
            "name": "type?",
            "type": "TextureDataType"
          },
          {
            "name": "anisotropy?",
            "type": "number"
          }
        ],
        "returnType": "VideoTexture"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "Audio",
    "type": "typeof Audio",
    "constructors": [
      {
        "parameters": [
          {
            "name": "listener",
            "type": "AudioListener"
          }
        ],
        "returnType": "Audio"
      }
    ],
    "properties": [
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "context",
        "type": "AudioContext"
      },
      {
        "name": "source",
        "type": "AudioBufferSourceNode"
      },
      {
        "name": "gain",
        "type": "GainNode"
      },
      {
        "name": "autoplay",
        "type": "boolean"
      },
      {
        "name": "startTime",
        "type": "number"
      },
      {
        "name": "playbackRate",
        "type": "number"
      },
      {
        "name": "hasPlaybackControl",
        "type": "boolean"
      },
      {
        "name": "isPlaying",
        "type": "boolean"
      },
      {
        "name": "sourceType",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "filters",
        "type": "any[]"
      },
      {
        "name": "getOutput",
        "type": "() => GainNode"
      },
      {
        "name": "setNodeSource",
        "type": "(audioNode: AudioBufferSourceNode) => Audio"
      },
      {
        "name": "setBuffer",
        "type": "(audioBuffer: AudioBuffer) => Audio"
      },
      {
        "name": "play",
        "type": "() => Audio"
      },
      {
        "name": "pause",
        "type": "() => Audio"
      },
      {
        "name": "stop",
        "type": "() => Audio"
      },
      {
        "name": "connect",
        "type": "() => Audio"
      },
      {
        "name": "disconnect",
        "type": "() => Audio"
      },
      {
        "name": "getFilters",
        "type": "() => any[]"
      },
      {
        "name": "setFilter",
        "type": "{ (value: any[]): Audio; (filter: any): Audio; }"
      },
      {
        "name": "getFilter",
        "type": "() => any"
      },
      {
        "name": "setPlaybackRate",
        "type": "(value: number) => Audio"
      },
      {
        "name": "getPlaybackRate",
        "type": "() => number"
      },
      {
        "name": "onEnded",
        "type": "() => void"
      },
      {
        "name": "getLoop",
        "type": "() => boolean"
      },
      {
        "name": "setLoop",
        "type": "(value: boolean) => void"
      },
      {
        "name": "getVolume",
        "type": "() => number"
      },
      {
        "name": "setVolume",
        "type": "(value: number) => Audio"
      },
      {
        "name": "load",
        "type": "(file: string) => Audio"
      }
    ]
  },
  {
    "name": "AudioAnalyser",
    "type": "typeof AudioAnalyser",
    "constructors": [
      {
        "parameters": [
          {
            "name": "audio",
            "type": "any"
          },
          {
            "name": "fftSize",
            "type": "number"
          }
        ],
        "returnType": "AudioAnalyser"
      }
    ],
    "properties": [
      {
        "name": "analyser",
        "type": "any"
      },
      {
        "name": "data",
        "type": "Uint8Array"
      }
    ],
    "methods": [
      {
        "name": "getFrequencyData",
        "type": "() => Uint8Array"
      },
      {
        "name": "getAverageFrequency",
        "type": "() => number"
      },
      {
        "name": "getData",
        "type": "(file: any) => any"
      }
    ]
  },
  {
    "name": "AudioBuffer",
    "type": "typeof AudioBuffer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "context",
            "type": "any"
          }
        ],
        "returnType": "AudioBuffer"
      }
    ],
    "properties": [
      {
        "name": "context",
        "type": "any"
      },
      {
        "name": "ready",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "readyCallbacks",
        "type": "Function[]"
      },
      {
        "name": "load",
        "type": "(file: string) => AudioBuffer"
      },
      {
        "name": "onReady",
        "type": "(callback: Function) => void"
      }
    ]
  },
  {
    "name": "PositionalAudio",
    "type": "typeof PositionalAudio",
    "constructors": [
      {
        "parameters": [
          {
            "name": "listener",
            "type": "AudioListener"
          }
        ],
        "returnType": "PositionalAudio"
      }
    ],
    "properties": [
      {
        "name": "panner",
        "type": "PannerNode"
      }
    ],
    "methods": [
      {
        "name": "setRefDistance",
        "type": "(value: number) => void"
      },
      {
        "name": "getRefDistance",
        "type": "() => number"
      },
      {
        "name": "setRolloffFactor",
        "type": "(value: number) => void"
      },
      {
        "name": "getRolloffFactor",
        "type": "() => number"
      },
      {
        "name": "setDistanceModel",
        "type": "(value: number) => void"
      },
      {
        "name": "getDistanceModel",
        "type": "() => number"
      },
      {
        "name": "setMaxDistance",
        "type": "(value: number) => void"
      },
      {
        "name": "getMaxDistance",
        "type": "() => number"
      }
    ]
  },
  {
    "name": "AudioListener",
    "type": "typeof AudioListener",
    "constructors": [
      {
        "returnType": "AudioListener"
      }
    ],
    "properties": [
      {
        "name": "type",
        "type": "string"
      },
      {
        "name": "context",
        "type": "AudioContext"
      },
      {
        "name": "gain",
        "type": "GainNode"
      }
    ],
    "methods": [
      {
        "name": "getInput",
        "type": "() => GainNode"
      },
      {
        "name": "removeFilter",
        "type": "() => void"
      },
      {
        "name": "setFilter",
        "type": "(value: any) => void"
      },
      {
        "name": "getFilter",
        "type": "() => any"
      },
      {
        "name": "setMasterVolume",
        "type": "(value: number) => void"
      },
      {
        "name": "getMasterVolume",
        "type": "() => number"
      }
    ]
  },
  {
    "name": "Curve",
    "type": "typeof Curve",
    "documentation": "An extensible curve object which contains methods for interpolation\r\nclass Curve&lt;T extends Vector&gt;",
    "constructors": [
      {
        "returnType": "Curve<T>"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "getPoint",
        "type": "(t: number) => T",
        "documentation": "Returns a vector for point t of the curve where t is between 0 and 1\r\ngetPoint(t: number): T;"
      },
      {
        "name": "getPointAt",
        "type": "(u: number) => T",
        "documentation": "Returns a vector for point at relative position in curve according to arc length\r\ngetPointAt(u: number): T;"
      },
      {
        "name": "getPoints",
        "type": "(divisions?: number) => T[]",
        "documentation": "Get sequence of points using getPoint( t )\r\ngetPoints(divisions?: number): T[];"
      },
      {
        "name": "getSpacedPoints",
        "type": "(divisions?: number) => T[]",
        "documentation": "Get sequence of equi-spaced points using getPointAt( u )\r\ngetSpacedPoints(divisions?: number): T[];"
      },
      {
        "name": "getLength",
        "type": "() => number",
        "documentation": "Get total curve arc length"
      },
      {
        "name": "getLengths",
        "type": "(divisions?: number) => number[]",
        "documentation": "Get list of cumulative segment lengths"
      },
      {
        "name": "updateArcLengths",
        "type": "() => void",
        "documentation": "Update the cumlative segment distance cache"
      },
      {
        "name": "getUtoTmapping",
        "type": "(u: number, distance: number) => number",
        "documentation": "Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance"
      },
      {
        "name": "getTangent",
        "type": "(t: number) => T",
        "documentation": "Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation\r\ngetTangent(t: number): T;"
      },
      {
        "name": "getTangentAt",
        "type": "(u: number) => T",
        "documentation": "Returns tangent at equidistance point u on the curve\r\ngetTangentAt(u: number): T;"
      }
    ]
  },
  {
    "name": "CurvePath",
    "type": "typeof CurvePath",
    "constructors": [
      {
        "returnType": "CurvePath<T>"
      }
    ],
    "properties": [
      {
        "name": "__constructor",
        "type": "any"
      },
      {
        "name": "autoClose",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "curves",
        "type": "Curve<T>[]"
      },
      {
        "name": "add",
        "type": "(curve: Curve<T>) => void"
      },
      {
        "name": "checkConnection",
        "type": "() => boolean"
      },
      {
        "name": "closePath",
        "type": "() => void"
      },
      {
        "name": "getPoint",
        "type": "(t: number) => T"
      },
      {
        "name": "getLength",
        "type": "() => number"
      },
      {
        "name": "updateArcLengths",
        "type": "() => void"
      },
      {
        "name": "getCurveLengths",
        "type": "() => number[]"
      },
      {
        "name": "getSpacedPoints",
        "type": "(divisions?: number) => T[]"
      },
      {
        "name": "getPoints",
        "type": "(divisions?: number) => T[]"
      },
      {
        "name": "createPointsGeometry",
        "type": "(divisions: number) => Geometry"
      },
      {
        "name": "createSpacedPointsGeometry",
        "type": "(divisions: number) => Geometry"
      },
      {
        "name": "createGeometry",
        "type": "(points: T[]) => Geometry"
      }
    ]
  },
  {
    "name": "PathAction",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "args",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "Path",
    "type": "typeof Path",
    "documentation": "a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points?",
            "type": "Vector2[]"
          }
        ],
        "returnType": "Path"
      }
    ],
    "properties": [
      {
        "name": "currentPoint",
        "type": "Vector2"
      }
    ],
    "methods": [
      {
        "name": "fromPoints",
        "type": "(vectors: Vector2[]) => void"
      },
      {
        "name": "moveTo",
        "type": "(x: number, y: number) => void"
      },
      {
        "name": "lineTo",
        "type": "(x: number, y: number) => void"
      },
      {
        "name": "quadraticCurveTo",
        "type": "(aCPx: number, aCPy: number, aX: number, aY: number) => void"
      },
      {
        "name": "bezierCurveTo",
        "type": "(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number) => void"
      },
      {
        "name": "splineThru",
        "type": "(pts: Vector2[]) => void"
      },
      {
        "name": "arc",
        "type": "(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boo..."
      },
      {
        "name": "absarc",
        "type": "(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boo..."
      },
      {
        "name": "ellipse",
        "type": "(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number..."
      },
      {
        "name": "absellipse",
        "type": "(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number..."
      }
    ]
  },
  {
    "name": "ShapePath",
    "type": "typeof ShapePath",
    "constructors": [
      {
        "returnType": "ShapePath"
      }
    ],
    "properties": [
      {
        "name": "currentPath",
        "type": "any"
      }
    ],
    "methods": [
      {
        "name": "subPaths",
        "type": "any[]"
      },
      {
        "name": "moveTo",
        "type": "(x: number, y: number) => void"
      },
      {
        "name": "lineTo",
        "type": "(x: number, y: number) => void"
      },
      {
        "name": "quadraticCurveTo",
        "type": "(aCPx: number, aCPy: number, aX: number, aY: number) => void"
      },
      {
        "name": "bezierCurveTo",
        "type": "(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number) => void"
      },
      {
        "name": "splineThru",
        "type": "(pts: Vector2[]) => void"
      },
      {
        "name": "toShapes",
        "type": "(isCCW: boolean, noHoles: any) => Shape[]"
      }
    ]
  },
  {
    "name": "Shape",
    "type": "typeof Shape",
    "documentation": "Defines a 2d shape plane using paths.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points?",
            "type": "Vector2[]"
          }
        ],
        "returnType": "Shape"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "holes",
        "type": "Path[]"
      },
      {
        "name": "extrude",
        "type": "(options?: any) => ExtrudeGeometry"
      },
      {
        "name": "makeGeometry",
        "type": "(options?: any) => ShapeGeometry"
      },
      {
        "name": "getPointsHoles",
        "type": "(divisions: number) => Vector2[][]"
      },
      {
        "name": "extractAllPoints",
        "type": "(divisions: number) => { shape: Vector2[]; holes: Vector2[][]; }"
      },
      {
        "name": "extractPoints",
        "type": "(divisions: number) => Vector2[]"
      }
    ]
  },
  {
    "name": "CatmullRomCurve3",
    "type": "typeof CatmullRomCurve3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points?",
            "type": "Vector3[]"
          }
        ],
        "returnType": "CatmullRomCurve3"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "points",
        "type": "Vector3[]"
      },
      {
        "name": "getPoint",
        "type": "(t: number) => Vector3"
      }
    ]
  },
  {
    "name": "CubicBezierCurve",
    "type": "typeof CubicBezierCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v0",
            "type": "Vector2"
          },
          {
            "name": "v1",
            "type": "Vector2"
          },
          {
            "name": "v2",
            "type": "Vector2"
          },
          {
            "name": "v3",
            "type": "Vector2"
          }
        ],
        "returnType": "CubicBezierCurve"
      }
    ],
    "properties": [
      {
        "name": "v0",
        "type": "Vector2"
      },
      {
        "name": "v1",
        "type": "Vector2"
      },
      {
        "name": "v2",
        "type": "Vector2"
      },
      {
        "name": "v3",
        "type": "Vector2"
      }
    ],
    "methods": []
  },
  {
    "name": "CubicBezierCurve3",
    "type": "typeof CubicBezierCurve3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v0",
            "type": "Vector3"
          },
          {
            "name": "v1",
            "type": "Vector3"
          },
          {
            "name": "v2",
            "type": "Vector3"
          },
          {
            "name": "v3",
            "type": "Vector3"
          }
        ],
        "returnType": "CubicBezierCurve3"
      }
    ],
    "properties": [
      {
        "name": "v0",
        "type": "Vector3"
      },
      {
        "name": "v1",
        "type": "Vector3"
      },
      {
        "name": "v2",
        "type": "Vector3"
      },
      {
        "name": "v3",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "getPoint",
        "type": "(t: number) => Vector3"
      }
    ]
  },
  {
    "name": "EllipseCurve",
    "type": "typeof EllipseCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "aX",
            "type": "number"
          },
          {
            "name": "aY",
            "type": "number"
          },
          {
            "name": "xRadius",
            "type": "number"
          },
          {
            "name": "yRadius",
            "type": "number"
          },
          {
            "name": "aStartAngle",
            "type": "number"
          },
          {
            "name": "aEndAngle",
            "type": "number"
          },
          {
            "name": "aClockwise",
            "type": "boolean"
          },
          {
            "name": "aRotation",
            "type": "number"
          }
        ],
        "returnType": "EllipseCurve"
      }
    ],
    "properties": [
      {
        "name": "aX",
        "type": "number"
      },
      {
        "name": "aY",
        "type": "number"
      },
      {
        "name": "xRadius",
        "type": "number"
      },
      {
        "name": "yRadius",
        "type": "number"
      },
      {
        "name": "aStartAngle",
        "type": "number"
      },
      {
        "name": "aEndAngle",
        "type": "number"
      },
      {
        "name": "aClockwise",
        "type": "boolean"
      },
      {
        "name": "aRotation",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "ArcCurve",
    "type": "typeof ArcCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "aX",
            "type": "number"
          },
          {
            "name": "aY",
            "type": "number"
          },
          {
            "name": "aRadius",
            "type": "number"
          },
          {
            "name": "aStartAngle",
            "type": "number"
          },
          {
            "name": "aEndAngle",
            "type": "number"
          },
          {
            "name": "aClockwise",
            "type": "boolean"
          }
        ],
        "returnType": "ArcCurve"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "LineCurve",
    "type": "typeof LineCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v1",
            "type": "Vector2"
          },
          {
            "name": "v2",
            "type": "Vector2"
          }
        ],
        "returnType": "LineCurve"
      }
    ],
    "properties": [
      {
        "name": "v1",
        "type": "Vector2"
      },
      {
        "name": "v2",
        "type": "Vector2"
      }
    ],
    "methods": []
  },
  {
    "name": "LineCurve3",
    "type": "typeof LineCurve3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v1",
            "type": "Vector3"
          },
          {
            "name": "v2",
            "type": "Vector3"
          }
        ],
        "returnType": "LineCurve3"
      }
    ],
    "properties": [
      {
        "name": "v1",
        "type": "Vector3"
      },
      {
        "name": "v2",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "getPoint",
        "type": "(t: number) => Vector3"
      }
    ]
  },
  {
    "name": "QuadraticBezierCurve",
    "type": "typeof QuadraticBezierCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v0",
            "type": "Vector2"
          },
          {
            "name": "v1",
            "type": "Vector2"
          },
          {
            "name": "v2",
            "type": "Vector2"
          }
        ],
        "returnType": "QuadraticBezierCurve"
      }
    ],
    "properties": [
      {
        "name": "v0",
        "type": "Vector2"
      },
      {
        "name": "v1",
        "type": "Vector2"
      },
      {
        "name": "v2",
        "type": "Vector2"
      }
    ],
    "methods": []
  },
  {
    "name": "QuadraticBezierCurve3",
    "type": "typeof QuadraticBezierCurve3",
    "constructors": [
      {
        "parameters": [
          {
            "name": "v0",
            "type": "Vector3"
          },
          {
            "name": "v1",
            "type": "Vector3"
          },
          {
            "name": "v2",
            "type": "Vector3"
          }
        ],
        "returnType": "QuadraticBezierCurve3"
      }
    ],
    "properties": [
      {
        "name": "v0",
        "type": "Vector3"
      },
      {
        "name": "v1",
        "type": "Vector3"
      },
      {
        "name": "v2",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "getPoint",
        "type": "(t: number) => Vector3"
      }
    ]
  },
  {
    "name": "SplineCurve",
    "type": "typeof SplineCurve",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points?",
            "type": "Vector2[]"
          }
        ],
        "returnType": "SplineCurve"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "points",
        "type": "Vector2[]"
      }
    ]
  },
  {
    "name": "BoxBufferGeometry",
    "type": "typeof BoxBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "depth",
            "type": "number"
          },
          {
            "name": "widthSegments?",
            "type": "number"
          },
          {
            "name": "heightSegments?",
            "type": "number"
          },
          {
            "name": "depthSegments?",
            "type": "number"
          }
        ],
        "returnType": "BoxBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ width: number; height: number; depth: number; widthSegments: number; heightSegments: number; de..."
      }
    ]
  },
  {
    "name": "BoxGeometry",
    "type": "typeof BoxGeometry",
    "documentation": "BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided within the (optional) 'width', 'height', & 'depth' constructor arguments.",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number",
            "documentation": "— Width of the sides on the X axis."
          },
          {
            "name": "height",
            "type": "number",
            "documentation": "— Height of the sides on the Y axis."
          },
          {
            "name": "depth",
            "type": "number",
            "documentation": "— Depth of the sides on the Z axis."
          },
          {
            "name": "widthSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the width of the sides."
          },
          {
            "name": "heightSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the height of the sides."
          },
          {
            "name": "depthSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the depth of the sides."
          }
        ],
        "returnType": "BoxGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ width: number; height: number; depth: number; widthSegments: number; heightSegments: number; de..."
      }
    ]
  },
  {
    "name": "CubeGeometry",
    "type": "typeof CubeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number",
            "documentation": "— Width of the sides on the X axis."
          },
          {
            "name": "height",
            "type": "number",
            "documentation": "— Height of the sides on the Y axis."
          },
          {
            "name": "depth",
            "type": "number",
            "documentation": "— Depth of the sides on the Z axis."
          },
          {
            "name": "widthSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the width of the sides."
          },
          {
            "name": "heightSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the height of the sides."
          },
          {
            "name": "depthSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces along the depth of the sides."
          }
        ],
        "returnType": "CubeGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "CircleBufferGeometry",
    "type": "typeof CircleBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "CircleBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; segments: number; thetaStart: number; thetaLength: number; }"
      }
    ]
  },
  {
    "name": "CircleGeometry",
    "type": "typeof CircleGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "CircleGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; segments: number; thetaStart: number; thetaLength: number; }"
      }
    ]
  },
  {
    "name": "CylinderBufferGeometry",
    "type": "typeof CylinderBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radiusTop?",
            "type": "number"
          },
          {
            "name": "radiusBottom?",
            "type": "number"
          },
          {
            "name": "height?",
            "type": "number"
          },
          {
            "name": "radialSegments?",
            "type": "number"
          },
          {
            "name": "heightSegments?",
            "type": "number"
          },
          {
            "name": "openEnded?",
            "type": "boolean"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "CylinderBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radiusTop: number; radiusBottom: number; height: number; radialSegments: number; heightSegments..."
      }
    ]
  },
  {
    "name": "CylinderGeometry",
    "type": "typeof CylinderGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radiusTop?",
            "type": "number",
            "documentation": "— Radius of the cylinder at the top."
          },
          {
            "name": "radiusBottom?",
            "type": "number",
            "documentation": "— Radius of the cylinder at the bottom."
          },
          {
            "name": "height?",
            "type": "number",
            "documentation": "— Height of the cylinder."
          },
          {
            "name": "radiusSegments?",
            "type": "number",
            "documentation": "— Number of segmented faces around the circumference of the cylinder."
          },
          {
            "name": "heightSegments?",
            "type": "number",
            "documentation": "— Number of rows of faces along the height of the cylinder."
          },
          {
            "name": "openEnded?",
            "type": "boolean",
            "documentation": "- A Boolean indicating whether or not to cap the ends of the cylinder."
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "CylinderGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radiusTop: number; radiusBottom: number; height: number; radialSegments: number; heightSegments..."
      }
    ]
  },
  {
    "name": "ConeBufferGeometry",
    "type": "typeof ConeBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "height?",
            "type": "number"
          },
          {
            "name": "radialSegment?",
            "type": "number"
          },
          {
            "name": "heightSegment?",
            "type": "number"
          },
          {
            "name": "openEnded?",
            "type": "boolean"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "ConeBufferGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ConeGeometry",
    "type": "typeof ConeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "height?",
            "type": "number"
          },
          {
            "name": "radialSegment?",
            "type": "number"
          },
          {
            "name": "heightSegment?",
            "type": "number"
          },
          {
            "name": "openEnded?",
            "type": "boolean"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "ConeGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "DodecahedronGeometry",
    "type": "typeof DodecahedronGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius",
            "type": "number"
          },
          {
            "name": "detail",
            "type": "number"
          }
        ],
        "returnType": "DodecahedronGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; detail: number; }"
      }
    ]
  },
  {
    "name": "EdgesGeometry",
    "type": "typeof EdgesGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry",
            "type": "BufferGeometry"
          },
          {
            "name": "thresholdAngle",
            "type": "number"
          }
        ],
        "returnType": "EdgesGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ExtrudeGeometry",
    "type": "typeof ExtrudeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "shape?",
            "type": "Shape"
          },
          {
            "name": "options?",
            "type": "any"
          }
        ],
        "returnType": "ExtrudeGeometry"
      },
      {
        "parameters": [
          {
            "name": "shapes?",
            "type": "Shape[]"
          },
          {
            "name": "options?",
            "type": "any"
          }
        ],
        "returnType": "ExtrudeGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "addShapeList",
        "type": "(shapes: Shape[], options?: any) => void"
      },
      {
        "name": "addShape",
        "type": "(shape: Shape, options?: any) => void"
      }
    ]
  },
  {
    "name": "IcosahedronGeometry",
    "type": "typeof IcosahedronGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius",
            "type": "number"
          },
          {
            "name": "detail",
            "type": "number"
          }
        ],
        "returnType": "IcosahedronGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "LatheBufferGeometry",
    "type": "typeof LatheBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points",
            "type": "Vector3[]"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "phiStart?",
            "type": "number"
          },
          {
            "name": "phiLength?",
            "type": "number"
          }
        ],
        "returnType": "LatheBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ points: Vector3[]; segments: number; phiStart: number; phiLength: number; }"
      }
    ]
  },
  {
    "name": "LatheGeometry",
    "type": "typeof LatheGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "points",
            "type": "Vector3[]"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "phiStart?",
            "type": "number"
          },
          {
            "name": "phiLength?",
            "type": "number"
          }
        ],
        "returnType": "LatheGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ points: Vector3[]; segments: number; phiStart: number; phiLength: number; }"
      }
    ]
  },
  {
    "name": "OctahedronGeometry",
    "type": "typeof OctahedronGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius",
            "type": "number"
          },
          {
            "name": "detail",
            "type": "number"
          }
        ],
        "returnType": "OctahedronGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ParametricGeometry",
    "type": "typeof ParametricGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "func",
            "type": "(u: number, v: number) => Vector3"
          },
          {
            "name": "slices",
            "type": "number"
          },
          {
            "name": "stacks",
            "type": "number"
          }
        ],
        "returnType": "ParametricGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ func: (u: number, v: number) => Vector3; slices: number; stacks: number; }"
      }
    ]
  },
  {
    "name": "PlaneBufferGeometry",
    "type": "typeof PlaneBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "widthSegments?",
            "type": "number"
          },
          {
            "name": "heightSegments?",
            "type": "number"
          }
        ],
        "returnType": "PlaneBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ width: number; height: number; widthSegments: number; heightSegments: number; }"
      }
    ]
  },
  {
    "name": "PlaneGeometry",
    "type": "typeof PlaneGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "width",
            "type": "number"
          },
          {
            "name": "height",
            "type": "number"
          },
          {
            "name": "widthSegments?",
            "type": "number"
          },
          {
            "name": "heightSegments?",
            "type": "number"
          }
        ],
        "returnType": "PlaneGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ width: number; height: number; widthSegments: number; heightSegments: number; }"
      }
    ]
  },
  {
    "name": "PolyhedronGeometry",
    "type": "typeof PolyhedronGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "vertices",
            "type": "number[]"
          },
          {
            "name": "indices",
            "type": "number[]"
          },
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "detail?",
            "type": "number"
          }
        ],
        "returnType": "PolyhedronGeometry"
      }
    ],
    "properties": [
      {
        "name": "boundingSphere",
        "type": "Sphere"
      }
    ],
    "methods": [
      {
        "name": "parameters",
        "type": "{ vertices: number[]; indices: number[]; radius: number; detail: number; }"
      }
    ]
  },
  {
    "name": "RingBufferGeometry",
    "type": "typeof RingBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "innerRadius?",
            "type": "number"
          },
          {
            "name": "outerRadius?",
            "type": "number"
          },
          {
            "name": "thetaSegments?",
            "type": "number"
          },
          {
            "name": "phiSegments?",
            "type": "number"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "RingBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ innerRadius: number; outerRadius: number; thetaSegments: number; phiSegments: number; thetaStar..."
      }
    ]
  },
  {
    "name": "RingGeometry",
    "type": "typeof RingGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "innerRadius?",
            "type": "number"
          },
          {
            "name": "outerRadius?",
            "type": "number"
          },
          {
            "name": "thetaSegments?",
            "type": "number"
          },
          {
            "name": "phiSegments?",
            "type": "number"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "RingGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ innerRadius: number; outerRadius: number; thetaSegments: number; phiSegments: number; thetaStar..."
      }
    ]
  },
  {
    "name": "ShapeGeometry",
    "type": "typeof ShapeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "shape",
            "type": "Shape"
          },
          {
            "name": "options?",
            "type": "any"
          }
        ],
        "returnType": "ShapeGeometry"
      },
      {
        "parameters": [
          {
            "name": "shapes",
            "type": "Shape[]"
          },
          {
            "name": "options?",
            "type": "any"
          }
        ],
        "returnType": "ShapeGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "addShapeList",
        "type": "(shapes: Shape[], options: any) => ShapeGeometry"
      },
      {
        "name": "addShape",
        "type": "(shape: Shape, options?: any) => void"
      }
    ]
  },
  {
    "name": "SphereBufferGeometry",
    "type": "typeof SphereBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius",
            "type": "number"
          },
          {
            "name": "widthSegments?",
            "type": "number"
          },
          {
            "name": "heightSegments?",
            "type": "number"
          },
          {
            "name": "phiStart?",
            "type": "number"
          },
          {
            "name": "phiLength?",
            "type": "number"
          },
          {
            "name": "thetaStart?",
            "type": "number"
          },
          {
            "name": "thetaLength?",
            "type": "number"
          }
        ],
        "returnType": "SphereBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; widthSegments: number; heightSegments: number; phiStart: number; phiLength: num..."
      }
    ]
  },
  {
    "name": "SphereGeometry",
    "type": "typeof SphereGeometry",
    "documentation": "A class for generating sphere geometries",
    "constructors": [
      {
        "documentation": "The geometry is created by sweeping and calculating vertexes around the Y axis (horizontal sweep) and the Z axis (vertical sweep). Thus, incomplete spheres (akin to 'sphere slices') can be created through the use of different values of phiStart, phiLength, thetaStart and thetaLength, in order to define the points in which we start (or end) calculating those vertices.",
        "parameters": [
          {
            "name": "radius",
            "type": "number",
            "documentation": "— sphere radius. Default is 50."
          },
          {
            "name": "widthSegments?",
            "type": "number",
            "documentation": "— number of horizontal segments. Minimum value is 3, and the default is 8."
          },
          {
            "name": "heightSegments?",
            "type": "number",
            "documentation": "— number of vertical segments. Minimum value is 2, and the default is 6."
          },
          {
            "name": "phiStart?",
            "type": "number",
            "documentation": "— specify horizontal starting angle. Default is 0."
          },
          {
            "name": "phiLength?",
            "type": "number",
            "documentation": "— specify horizontal sweep angle size. Default is Math.PI * 2."
          },
          {
            "name": "thetaStart?",
            "type": "number",
            "documentation": "— specify vertical starting angle. Default is 0."
          },
          {
            "name": "thetaLength?",
            "type": "number",
            "documentation": "— specify vertical sweep angle size. Default is Math.PI."
          }
        ],
        "returnType": "SphereGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; widthSegments: number; heightSegments: number; phiStart: number; phiLength: num..."
      }
    ]
  },
  {
    "name": "TetrahedronGeometry",
    "type": "typeof TetrahedronGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "detail?",
            "type": "number"
          }
        ],
        "returnType": "TetrahedronGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "TextGeometryParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "size?",
        "type": "number"
      },
      {
        "name": "height?",
        "type": "number"
      },
      {
        "name": "curveSegments?",
        "type": "number"
      },
      {
        "name": "bevelEnabled?",
        "type": "boolean"
      },
      {
        "name": "bevelThickness?",
        "type": "number"
      },
      {
        "name": "bevelSize?",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "TextGeometry",
    "type": "typeof TextGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "text",
            "type": "string"
          },
          {
            "name": "parameters?",
            "type": "TextGeometryParameters"
          }
        ],
        "returnType": "TextGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ font: Font; size: number; height: number; curveSegments: number; bevelEnabled: boolean; bevelTh..."
      }
    ]
  },
  {
    "name": "TorusBufferGeometry",
    "type": "typeof TorusBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "tube?",
            "type": "number"
          },
          {
            "name": "radialSegments?",
            "type": "number"
          },
          {
            "name": "tubularSegments?",
            "type": "number"
          },
          {
            "name": "arc?",
            "type": "number"
          }
        ],
        "returnType": "TorusBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; tube: number; radialSegments: number; tubularSegments: number; arc: number; }"
      }
    ]
  },
  {
    "name": "TorusGeometry",
    "type": "typeof TorusGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "tube?",
            "type": "number"
          },
          {
            "name": "radialSegments?",
            "type": "number"
          },
          {
            "name": "tubularSegments?",
            "type": "number"
          },
          {
            "name": "arc?",
            "type": "number"
          }
        ],
        "returnType": "TorusGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; tube: number; radialSegments: number; tubularSegments: number; arc: number; }"
      }
    ]
  },
  {
    "name": "TorusKnotBufferGeometry",
    "type": "typeof TorusKnotBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "tube?",
            "type": "number"
          },
          {
            "name": "radialSegments?",
            "type": "number"
          },
          {
            "name": "tubularSegments?",
            "type": "number"
          },
          {
            "name": "p?",
            "type": "number"
          },
          {
            "name": "q?",
            "type": "number"
          },
          {
            "name": "heightScale?",
            "type": "number"
          }
        ],
        "returnType": "TorusKnotBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; tube: number; radialSegments: number; tubularSegments: number; p: number; q: nu..."
      }
    ]
  },
  {
    "name": "TorusKnotGeometry",
    "type": "typeof TorusKnotGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "tube?",
            "type": "number"
          },
          {
            "name": "radialSegments?",
            "type": "number"
          },
          {
            "name": "tubularSegments?",
            "type": "number"
          },
          {
            "name": "p?",
            "type": "number"
          },
          {
            "name": "q?",
            "type": "number"
          },
          {
            "name": "heightScale?",
            "type": "number"
          }
        ],
        "returnType": "TorusKnotGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ radius: number; tube: number; radialSegments: number; tubularSegments: number; p: number; q: nu..."
      }
    ]
  },
  {
    "name": "TubeGeometry",
    "type": "typeof TubeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "path",
            "type": "Curve<Vector3>"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "radiusSegments?",
            "type": "number"
          },
          {
            "name": "closed?",
            "type": "boolean"
          },
          {
            "name": "taper?",
            "type": "(u: number) => number"
          }
        ],
        "returnType": "TubeGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ path: Curve<Vector3>; segments: number; radius: number; radialSegments: number; closed: boolean..."
      },
      {
        "name": "tangents",
        "type": "Vector3[]"
      },
      {
        "name": "normals",
        "type": "Vector3[]"
      },
      {
        "name": "binormals",
        "type": "Vector3[]"
      }
    ]
  },
  {
    "name": "TubeBufferGeometry",
    "type": "typeof TubeBufferGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "path",
            "type": "Curve<Vector3>"
          },
          {
            "name": "segments?",
            "type": "number"
          },
          {
            "name": "radius?",
            "type": "number"
          },
          {
            "name": "radiusSegments?",
            "type": "number"
          },
          {
            "name": "closed?",
            "type": "boolean"
          }
        ],
        "returnType": "TubeBufferGeometry"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parameters",
        "type": "{ path: Curve<Vector3>; segments: number; radius: number; radialSegments: number; closed: boolean..."
      },
      {
        "name": "tangents",
        "type": "Vector3[]"
      },
      {
        "name": "normals",
        "type": "Vector3[]"
      },
      {
        "name": "binormals",
        "type": "Vector3[]"
      }
    ]
  },
  {
    "name": "WireframeGeometry",
    "type": "typeof WireframeGeometry",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry",
            "type": "BufferGeometry | Geometry"
          }
        ],
        "returnType": "WireframeGeometry"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ArrowHelper",
    "type": "typeof ArrowHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "dir",
            "type": "Vector3"
          },
          {
            "name": "origin?",
            "type": "Vector3"
          },
          {
            "name": "length?",
            "type": "number"
          },
          {
            "name": "hex?",
            "type": "number"
          },
          {
            "name": "headLength?",
            "type": "number"
          },
          {
            "name": "headWidth?",
            "type": "number"
          }
        ],
        "returnType": "ArrowHelper"
      }
    ],
    "properties": [
      {
        "name": "line",
        "type": "Line"
      },
      {
        "name": "cone",
        "type": "Mesh"
      }
    ],
    "methods": [
      {
        "name": "setDirection",
        "type": "(dir: Vector3) => void"
      },
      {
        "name": "setLength",
        "type": "(length: number, headLength?: number, headWidth?: number) => void"
      },
      {
        "name": "setColor",
        "type": "(hex: number) => void"
      }
    ]
  },
  {
    "name": "AxisHelper",
    "type": "typeof AxisHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "size?",
            "type": "number"
          }
        ],
        "returnType": "AxisHelper"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "BoundingBoxHelper",
    "type": "typeof BoundingBoxHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object?",
            "type": "Object3D"
          },
          {
            "name": "hex?",
            "type": "number"
          }
        ],
        "returnType": "BoundingBoxHelper"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      },
      {
        "name": "box",
        "type": "Box3"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "BoxHelper",
    "type": "typeof BoxHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object?",
            "type": "Object3D"
          },
          {
            "name": "color?",
            "type": "Color"
          }
        ],
        "returnType": "BoxHelper"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "update",
        "type": "(object?: Object3D) => void"
      }
    ]
  },
  {
    "name": "CameraHelper",
    "type": "typeof CameraHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "CameraHelper"
      }
    ],
    "properties": [
      {
        "name": "camera",
        "type": "Camera"
      }
    ],
    "methods": [
      {
        "name": "pointMap",
        "type": "{ [id: string]: number[]; }"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "DirectionalLightHelper",
    "type": "typeof DirectionalLightHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "light",
            "type": "Light"
          },
          {
            "name": "size?",
            "type": "number"
          }
        ],
        "returnType": "DirectionalLightHelper"
      }
    ],
    "properties": [
      {
        "name": "light",
        "type": "Light"
      },
      {
        "name": "lightPlane",
        "type": "Line"
      }
    ],
    "methods": [
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "EdgesHelper",
    "type": "typeof EdgesHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Object3D"
          },
          {
            "name": "hex?",
            "type": "number"
          },
          {
            "name": "thresholdAngle?",
            "type": "number"
          }
        ],
        "returnType": "EdgesHelper"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "FaceNormalsHelper",
    "type": "typeof FaceNormalsHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Object3D"
          },
          {
            "name": "size?",
            "type": "number"
          },
          {
            "name": "hex?",
            "type": "number"
          },
          {
            "name": "linewidth?",
            "type": "number"
          }
        ],
        "returnType": "FaceNormalsHelper"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      },
      {
        "name": "size",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "(object?: Object3D) => void"
      }
    ]
  },
  {
    "name": "GridHelper",
    "type": "typeof GridHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "size",
            "type": "number"
          },
          {
            "name": "divisions",
            "type": "number"
          },
          {
            "name": "color1?",
            "type": "number | Color"
          },
          {
            "name": "color2?",
            "type": "number | Color"
          }
        ],
        "returnType": "GridHelper"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "setColors",
        "type": "(color1?: number | Color, color2?: number | Color) => void"
      }
    ]
  },
  {
    "name": "HemisphereLightHelper",
    "type": "typeof HemisphereLightHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "light",
            "type": "Light"
          },
          {
            "name": "sphereSize",
            "type": "number"
          }
        ],
        "returnType": "HemisphereLightHelper"
      }
    ],
    "properties": [
      {
        "name": "light",
        "type": "Light"
      },
      {
        "name": "lightSphere",
        "type": "Mesh"
      }
    ],
    "methods": [
      {
        "name": "colors",
        "type": "Color[]"
      },
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "PointLightHelper",
    "type": "typeof PointLightHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "light",
            "type": "Light"
          },
          {
            "name": "sphereSize",
            "type": "number"
          }
        ],
        "returnType": "PointLightHelper"
      }
    ],
    "properties": [
      {
        "name": "light",
        "type": "Light"
      }
    ],
    "methods": [
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "SkeletonHelper",
    "type": "typeof SkeletonHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "bone",
            "type": "Object3D"
          }
        ],
        "returnType": "SkeletonHelper"
      }
    ],
    "properties": [
      {
        "name": "root",
        "type": "Object3D"
      }
    ],
    "methods": [
      {
        "name": "bones",
        "type": "Bone[]"
      },
      {
        "name": "getBoneList",
        "type": "(object: Object3D) => Bone[]"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "SpotLightHelper",
    "type": "typeof SpotLightHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "light",
            "type": "Light"
          }
        ],
        "returnType": "SpotLightHelper"
      }
    ],
    "properties": [
      {
        "name": "light",
        "type": "Light"
      }
    ],
    "methods": [
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "update",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "VertexNormalsHelper",
    "type": "typeof VertexNormalsHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Object3D"
          },
          {
            "name": "size?",
            "type": "number"
          },
          {
            "name": "hex?",
            "type": "number"
          },
          {
            "name": "linewidth?",
            "type": "number"
          }
        ],
        "returnType": "VertexNormalsHelper"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      },
      {
        "name": "size",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "(object?: Object3D) => void"
      }
    ]
  },
  {
    "name": "WireframeHelper",
    "type": "typeof WireframeHelper",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Object3D"
          },
          {
            "name": "hex?",
            "type": "number"
          }
        ],
        "returnType": "WireframeHelper"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "ImmediateRenderObject",
    "type": "typeof ImmediateRenderObject",
    "constructors": [
      {
        "parameters": [
          {
            "name": "material",
            "type": "Material"
          }
        ],
        "returnType": "ImmediateRenderObject"
      }
    ],
    "properties": [
      {
        "name": "material",
        "type": "Material"
      }
    ],
    "methods": [
      {
        "name": "render",
        "type": "(renderCallback: Function) => void"
      }
    ]
  },
  {
    "name": "MorphBlendMeshAnimation",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "end",
        "type": "number"
      },
      {
        "name": "length",
        "type": "number"
      },
      {
        "name": "fps",
        "type": "number"
      },
      {
        "name": "duration",
        "type": "number"
      },
      {
        "name": "lastFrame",
        "type": "number"
      },
      {
        "name": "currentFrame",
        "type": "number"
      },
      {
        "name": "active",
        "type": "boolean"
      },
      {
        "name": "time",
        "type": "number"
      },
      {
        "name": "direction",
        "type": "number"
      },
      {
        "name": "weight",
        "type": "number"
      },
      {
        "name": "directionBackwards",
        "type": "boolean"
      },
      {
        "name": "mirroredLoop",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "MorphBlendMesh",
    "type": "typeof MorphBlendMesh",
    "constructors": [
      {
        "parameters": [
          {
            "name": "geometry",
            "type": "Geometry"
          },
          {
            "name": "material",
            "type": "Material"
          }
        ],
        "returnType": "MorphBlendMesh"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "animationsMap",
        "type": "{ [name: string]: MorphBlendMeshAnimation; }"
      },
      {
        "name": "animationsList",
        "type": "MorphBlendMeshAnimation[]"
      },
      {
        "name": "createAnimation",
        "type": "(name: string, start: number, end: number, fps: number) => void"
      },
      {
        "name": "autoCreateAnimations",
        "type": "(fps: number) => void"
      },
      {
        "name": "setAnimationDirectionForward",
        "type": "(name: string) => void"
      },
      {
        "name": "setAnimationDirectionBackward",
        "type": "(name: string) => void"
      },
      {
        "name": "setAnimationFPS",
        "type": "(name: string, fps: number) => void"
      },
      {
        "name": "setAnimationDuration",
        "type": "(name: string, duration: number) => void"
      },
      {
        "name": "setAnimationWeight",
        "type": "(name: string, weight: number) => void"
      },
      {
        "name": "setAnimationTime",
        "type": "(name: string, time: number) => void"
      },
      {
        "name": "getAnimationTime",
        "type": "(name: string) => number"
      },
      {
        "name": "getAnimationDuration",
        "type": "(name: string) => number"
      },
      {
        "name": "playAnimation",
        "type": "(name: string) => void"
      },
      {
        "name": "stopAnimation",
        "type": "(name: string) => void"
      },
      {
        "name": "update",
        "type": "(delta: number) => void"
      }
    ]
  },
  {
    "name": "SpriteCanvasMaterialParameters",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": [
      {
        "name": "program?",
        "type": "(context: CanvasRenderingContext2D, color: Color) => void"
      }
    ]
  },
  {
    "name": "SpriteCanvasMaterial",
    "type": "typeof SpriteCanvasMaterial",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "SpriteCanvasMaterialParameters"
          }
        ],
        "returnType": "SpriteCanvasMaterial"
      }
    ],
    "properties": [
      {
        "name": "color",
        "type": "Color"
      }
    ],
    "methods": [
      {
        "name": "program",
        "type": "(context: CanvasRenderingContext2D, color: Color) => void"
      }
    ]
  },
  {
    "name": "CanvasRendererParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "devicePixelRatio?",
        "type": "number"
      },
      {
        "name": "alpha?",
        "type": "boolean"
      }
    ],
    "methods": []
  },
  {
    "name": "CanvasRenderer",
    "type": "typeof CanvasRenderer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "CanvasRendererParameters"
          }
        ],
        "returnType": "CanvasRenderer"
      }
    ],
    "properties": [
      {
        "name": "domElement",
        "type": "HTMLCanvasElement"
      },
      {
        "name": "autoClear",
        "type": "boolean"
      },
      {
        "name": "sortObjects",
        "type": "boolean"
      },
      {
        "name": "sortElements",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "info",
        "type": "{ render: { vertices: number; faces: number; }; }"
      },
      {
        "name": "supportsVertexTextures",
        "type": "() => void"
      },
      {
        "name": "setFaceCulling",
        "type": "() => void"
      },
      {
        "name": "getPixelRatio",
        "type": "() => number"
      },
      {
        "name": "setPixelRatio",
        "type": "(value: number) => void"
      },
      {
        "name": "setSize",
        "type": "(width: number, height: number, updateStyle?: boolean) => void"
      },
      {
        "name": "setViewport",
        "type": "(x: number, y: number, width: number, height: number) => void"
      },
      {
        "name": "setScissor",
        "type": "() => void"
      },
      {
        "name": "enableScissorTest",
        "type": "() => void"
      },
      {
        "name": "setClearColor",
        "type": "(color: string | number | Color, opacity?: number) => void"
      },
      {
        "name": "setClearColorHex",
        "type": "(hex: number, alpha?: number) => void"
      },
      {
        "name": "getClearColor",
        "type": "() => Color"
      },
      {
        "name": "getClearAlpha",
        "type": "() => number"
      },
      {
        "name": "getMaxAnisotropy",
        "type": "() => number"
      },
      {
        "name": "clear",
        "type": "() => void"
      },
      {
        "name": "clearColor",
        "type": "() => void"
      },
      {
        "name": "clearDepth",
        "type": "() => void"
      },
      {
        "name": "clearStencil",
        "type": "() => void"
      },
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera) => void"
      }
    ]
  },
  {
    "name": "ColladaLoaderReturnType",
    "type": "any",
    "constructors": [],
    "properties": [],
    "methods": []
  },
  {
    "name": "ColladaModel",
    "type": "typeof ColladaModel",
    "constructors": [
      {
        "returnType": "ColladaModel"
      }
    ],
    "properties": [
      {
        "name": "kinematics",
        "type": "any"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "library",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "ColladaLoader",
    "type": "typeof ColladaLoader",
    "constructors": [
      {
        "returnType": "ColladaLoader"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: (model: ColladaModel) => void, onProgress?: (request: ProgressEvent) => voi..."
      },
      {
        "name": "setCrossOrigin",
        "type": "(value: any) => void"
      },
      {
        "name": "parse",
        "type": "(text: string) => ColladaModel"
      }
    ]
  },
  {
    "name": "CSS3DObject",
    "type": "typeof CSS3DObject",
    "constructors": [
      {
        "parameters": [
          {
            "name": "element",
            "type": "any"
          }
        ],
        "returnType": "CSS3DObject"
      }
    ],
    "properties": [
      {
        "name": "element",
        "type": "any"
      }
    ],
    "methods": []
  },
  {
    "name": "CSS3DSprite",
    "type": "typeof CSS3DSprite",
    "constructors": [
      {
        "parameters": [
          {
            "name": "element",
            "type": "any"
          }
        ],
        "returnType": "CSS3DSprite"
      }
    ],
    "properties": [],
    "methods": []
  },
  {
    "name": "CSS3DRenderer",
    "type": "typeof CSS3DRenderer",
    "constructors": [
      {
        "returnType": "CSS3DRenderer"
      }
    ],
    "properties": [
      {
        "name": "domElement",
        "type": "HTMLElement"
      }
    ],
    "methods": [
      {
        "name": "setSize",
        "type": "(width: number, height: number) => void"
      },
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera) => void"
      }
    ]
  },
  {
    "name": "CTMLoader",
    "type": "typeof CTMLoader",
    "constructors": [
      {
        "returnType": "CTMLoader"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "loadParts",
        "type": "(url: string, callback: () => any, parameters?: any) => any",
        "documentation": "load multiple CTM parts defined in JSON."
      },
      {
        "name": "load",
        "type": "(url: string, callback: (geo: any) => any, parameters?: any) => any",
        "documentation": "Load CTMLoader compressed models"
      },
      {
        "name": "createModel",
        "type": "(file: string, callback: () => any) => any",
        "documentation": "create buffergeometry by ctm file."
      }
    ]
  },
  {
    "name": "Dds",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "width",
        "type": "number"
      },
      {
        "name": "height",
        "type": "number"
      },
      {
        "name": "format",
        "type": "CompressedPixelFormat"
      },
      {
        "name": "mipmapCount",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "DDSLoader",
    "type": "typeof DDSLoader",
    "constructors": [
      {
        "returnType": "DDSLoader"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "parse",
        "type": "(buffer: string, loadMipmaps: boolean) => Dds"
      }
    ]
  },
  {
    "name": "EditorControls",
    "type": "typeof EditorControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "EditorControls"
      }
    ],
    "properties": [
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "center",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "focus",
        "type": "(target: Object3D, frame: boolean) => void"
      },
      {
        "name": "pan",
        "type": "(delta: Vector3) => void"
      },
      {
        "name": "zoom",
        "type": "(delta: Vector3) => void"
      },
      {
        "name": "rotate",
        "type": "(delta: Vector3) => void"
      },
      {
        "name": "dispose",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "ShaderPass",
    "type": "typeof ShaderPass",
    "constructors": [
      {
        "parameters": [
          {
            "name": "shader",
            "type": "Shader"
          },
          {
            "name": "textureID?",
            "type": "string"
          }
        ],
        "returnType": "ShaderPass"
      }
    ],
    "properties": [
      {
        "name": "textureID",
        "type": "string"
      },
      {
        "name": "uniforms",
        "type": "any"
      },
      {
        "name": "material",
        "type": "ShaderMaterial"
      },
      {
        "name": "renderToScreen",
        "type": "boolean"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "needsSwap",
        "type": "boolean"
      },
      {
        "name": "clear",
        "type": "boolean"
      },
      {
        "name": "camera",
        "type": "Camera"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "quad",
        "type": "Mesh"
      }
    ],
    "methods": [
      {
        "name": "render",
        "type": "(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, delta: n..."
      }
    ]
  },
  {
    "name": "EffectComposer",
    "type": "typeof EffectComposer",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "WebGLRenderer"
          },
          {
            "name": "renderTarget?",
            "type": "WebGLRenderTarget"
          }
        ],
        "returnType": "EffectComposer"
      }
    ],
    "properties": [
      {
        "name": "renderTarget1",
        "type": "WebGLRenderTarget"
      },
      {
        "name": "renderTarget2",
        "type": "WebGLRenderTarget"
      },
      {
        "name": "writeBuffer",
        "type": "WebGLRenderTarget"
      },
      {
        "name": "readBuffer",
        "type": "WebGLRenderTarget"
      },
      {
        "name": "copyPass",
        "type": "ShaderPass"
      }
    ],
    "methods": [
      {
        "name": "passes",
        "type": "any[]"
      },
      {
        "name": "swapBuffers",
        "type": "() => void"
      },
      {
        "name": "addPass",
        "type": "(pass: any) => void"
      },
      {
        "name": "insertPass",
        "type": "(pass: any, index: number) => void"
      },
      {
        "name": "render",
        "type": "(delta?: number) => void"
      },
      {
        "name": "reset",
        "type": "(renderTarget?: WebGLRenderTarget) => void"
      },
      {
        "name": "setSize",
        "type": "(width: number, height: number) => void"
      }
    ]
  },
  {
    "name": "FBXLoader",
    "type": "typeof FBXLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "FBXLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      }
    ],
    "methods": [
      {
        "name": "load",
        "type": "(url: string, onLoad: (group: Group) => void, onProgress?: (event: ProgressEvent) => void, onErro..."
      },
      {
        "name": "parse",
        "type": "(FBXText: string, resourceDirectory: string) => Group"
      }
    ]
  },
  {
    "name": "FirstPersonControls",
    "type": "typeof FirstPersonControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "FirstPersonControls"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "movementSpeed",
        "type": "number"
      },
      {
        "name": "lookSpeed",
        "type": "number"
      },
      {
        "name": "noFly",
        "type": "boolean"
      },
      {
        "name": "lookVertical",
        "type": "boolean"
      },
      {
        "name": "autoForward",
        "type": "boolean"
      },
      {
        "name": "activeLook",
        "type": "boolean"
      },
      {
        "name": "heightSpeed",
        "type": "boolean"
      },
      {
        "name": "heightCoef",
        "type": "number"
      },
      {
        "name": "heightMin",
        "type": "number"
      },
      {
        "name": "heightMax",
        "type": "number"
      },
      {
        "name": "constrainVertical",
        "type": "boolean"
      },
      {
        "name": "verticalMin",
        "type": "number"
      },
      {
        "name": "verticalMax",
        "type": "number"
      },
      {
        "name": "autoSpeedFactor",
        "type": "number"
      },
      {
        "name": "mouseX",
        "type": "number"
      },
      {
        "name": "mouseY",
        "type": "number"
      },
      {
        "name": "lat",
        "type": "number"
      },
      {
        "name": "lon",
        "type": "number"
      },
      {
        "name": "phi",
        "type": "number"
      },
      {
        "name": "theta",
        "type": "number"
      },
      {
        "name": "moveForward",
        "type": "boolean"
      },
      {
        "name": "moveBackward",
        "type": "boolean"
      },
      {
        "name": "moveLeft",
        "type": "boolean"
      },
      {
        "name": "moveRight",
        "type": "boolean"
      },
      {
        "name": "freeze",
        "type": "boolean"
      },
      {
        "name": "mouseDragOn",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "domElement",
        "type": "HTMLCanvasElement | HTMLDocument"
      },
      {
        "name": "update",
        "type": "(delta: number) => void"
      },
      {
        "name": "dispose",
        "type": "() => void"
      }
    ]
  },
  {
    "name": "MaskPass",
    "type": "typeof MaskPass",
    "constructors": [
      {
        "parameters": [
          {
            "name": "scene",
            "type": "Scene"
          },
          {
            "name": "camera",
            "type": "Camera"
          }
        ],
        "returnType": "MaskPass"
      }
    ],
    "properties": [
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "camera",
        "type": "Camera"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "clear",
        "type": "boolean"
      },
      {
        "name": "needsSwap",
        "type": "boolean"
      },
      {
        "name": "inverse",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "render",
        "type": "(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, delta: n..."
      }
    ]
  },
  {
    "name": "ClearMaskPass",
    "type": "typeof ClearMaskPass",
    "constructors": [
      {
        "returnType": "ClearMaskPass"
      }
    ],
    "properties": [
      {
        "name": "enabled",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "render",
        "type": "(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, delta: n..."
      }
    ]
  },
  {
    "name": "MTLLoader",
    "type": "typeof MTLLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "MTLLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "path",
        "type": "string"
      },
      {
        "name": "texturePath",
        "type": "string"
      },
      {
        "name": "crossOrigin",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "materialOptions",
        "type": "{}"
      },
      {
        "name": "materials",
        "type": "Material[]"
      },
      {
        "name": "load",
        "type": "(url: string, onLoad: (materialCreator: MaterialCreator) => void, onProgress?: (event: ProgressEv..."
      },
      {
        "name": "parse",
        "type": "(text: string) => MaterialCreator"
      },
      {
        "name": "setPath",
        "type": "(path: string) => void"
      },
      {
        "name": "setTexturePath",
        "type": "(path: string) => void"
      },
      {
        "name": "setBaseUrl",
        "type": "(path: string) => void"
      },
      {
        "name": "setCrossOrigin",
        "type": "(value: boolean) => void"
      },
      {
        "name": "setMaterialOptions",
        "type": "(value: any) => void"
      }
    ]
  },
  {
    "name": "MaterialCreator",
    "type": "typeof MaterialCreator",
    "constructors": [
      {
        "parameters": [
          {
            "name": "baseUrl?",
            "type": "string"
          },
          {
            "name": "options?",
            "type": "any"
          }
        ],
        "returnType": "MaterialCreator"
      }
    ],
    "properties": [
      {
        "name": "baseUrl",
        "type": "string"
      },
      {
        "name": "options",
        "type": "any"
      },
      {
        "name": "materialsInfo",
        "type": "any"
      },
      {
        "name": "materials",
        "type": "any"
      },
      {
        "name": "nameLookup",
        "type": "any"
      },
      {
        "name": "side",
        "type": "number"
      },
      {
        "name": "wrap",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "materialsArray",
        "type": "Material[]"
      },
      {
        "name": "setCrossOrigin",
        "type": "(value: boolean) => void"
      },
      {
        "name": "setManager",
        "type": "(value: any) => void"
      },
      {
        "name": "setMaterials",
        "type": "(materialsInfo: any) => void"
      },
      {
        "name": "convert",
        "type": "(materialsInfo: any) => any"
      },
      {
        "name": "preload",
        "type": "() => void"
      },
      {
        "name": "getIndex",
        "type": "(materialName: string) => Material"
      },
      {
        "name": "getAsArray",
        "type": "() => Material[]"
      },
      {
        "name": "create",
        "type": "(materialName: string) => Material"
      },
      {
        "name": "createMaterial_",
        "type": "(materialName: string) => Material"
      },
      {
        "name": "getTextureParams",
        "type": "(value: string, matParams: any) => any"
      },
      {
        "name": "loadTexture",
        "type": "(url: string, mapping: any, onLoad: (bufferGeometry: BufferGeometry) => void, onProgress?: (event..."
      }
    ]
  },
  {
    "name": "OBJLoader",
    "type": "typeof OBJLoader",
    "constructors": [
      {
        "parameters": [
          {
            "name": "manager?",
            "type": "LoadingManager"
          }
        ],
        "returnType": "OBJLoader"
      }
    ],
    "properties": [
      {
        "name": "manager",
        "type": "LoadingManager"
      },
      {
        "name": "regexp",
        "type": "any"
      },
      {
        "name": "path",
        "type": "string"
      }
    ],
    "methods": [
      {
        "name": "materials",
        "type": "Material[]"
      },
      {
        "name": "load",
        "type": "(url: string, onLoad: (group: Group) => void, onProgress?: (event: ProgressEvent) => void, onErro..."
      },
      {
        "name": "parse",
        "type": "(data: string) => Group"
      },
      {
        "name": "setPath",
        "type": "(value: string) => void"
      },
      {
        "name": "setMaterials",
        "type": "(materials: MaterialCreator) => void"
      },
      {
        "name": "_createParserState",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "Octree",
    "type": "typeof Octree",
    "constructors": [
      {
        "parameters": [
          {
            "name": "parameters?",
            "type": "any"
          }
        ],
        "returnType": "Octree"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "add",
        "type": "(object: any, options?: any) => any"
      },
      {
        "name": "addDeferred",
        "type": "(object: any, options?: any) => any"
      },
      {
        "name": "addObjectData",
        "type": "(object: any, part: any) => any"
      },
      {
        "name": "remove",
        "type": "(object: any) => any"
      },
      {
        "name": "extend",
        "type": "(octree: Octree) => any"
      },
      {
        "name": "rebuild",
        "type": "() => any"
      },
      {
        "name": "updateObject",
        "type": "(object: any) => any"
      },
      {
        "name": "search",
        "type": "(position: Vector3, radius: number, organizeByObject: boolean, direction: Vector3) => any"
      },
      {
        "name": "setRoot",
        "type": "(root: any) => any"
      },
      {
        "name": "getDepthEnd",
        "type": "() => number"
      },
      {
        "name": "getNodeCountEnd",
        "type": "() => number"
      },
      {
        "name": "getObjectCountEnd",
        "type": "() => number"
      },
      {
        "name": "toConsole",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "OrbitControls",
    "type": "typeof OrbitControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "OrbitControls"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Camera"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "center",
        "type": "Vector3"
      },
      {
        "name": "enableZoom",
        "type": "boolean"
      },
      {
        "name": "zoomSpeed",
        "type": "number"
      },
      {
        "name": "minDistance",
        "type": "number"
      },
      {
        "name": "maxDistance",
        "type": "number"
      },
      {
        "name": "enableRotate",
        "type": "boolean"
      },
      {
        "name": "rotateSpeed",
        "type": "number"
      },
      {
        "name": "enablePan",
        "type": "boolean"
      },
      {
        "name": "keyPanSpeed",
        "type": "number"
      },
      {
        "name": "autoRotate",
        "type": "boolean"
      },
      {
        "name": "autoRotateSpeed",
        "type": "number"
      },
      {
        "name": "minPolarAngle",
        "type": "number"
      },
      {
        "name": "maxPolarAngle",
        "type": "number"
      },
      {
        "name": "minAzimuthAngle",
        "type": "number"
      },
      {
        "name": "maxAzimuthAngle",
        "type": "number"
      },
      {
        "name": "enableKeys",
        "type": "boolean"
      },
      {
        "name": "enableDamping",
        "type": "boolean"
      },
      {
        "name": "dampingFactor",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "domElement",
        "type": "HTMLElement | HTMLDocument"
      },
      {
        "name": "keys",
        "type": "{ LEFT: number; UP: number; RIGHT: number; BOTTOM: number; }"
      },
      {
        "name": "mouseButtons",
        "type": "{ ORBIT: MOUSE; ZOOM: MOUSE; PAN: MOUSE; }"
      },
      {
        "name": "rotateLeft",
        "type": "(angle?: number) => void"
      },
      {
        "name": "rotateUp",
        "type": "(angle?: number) => void"
      },
      {
        "name": "panLeft",
        "type": "(distance?: number) => void"
      },
      {
        "name": "panUp",
        "type": "(distance?: number) => void"
      },
      {
        "name": "pan",
        "type": "(deltaX: number, deltaY: number) => void"
      },
      {
        "name": "dollyIn",
        "type": "(dollyScale: number) => void"
      },
      {
        "name": "dollyOut",
        "type": "(dollyScale: number) => void"
      },
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      },
      {
        "name": "dispose",
        "type": "() => void"
      },
      {
        "name": "getPolarAngle",
        "type": "() => number"
      },
      {
        "name": "getAzimuthalAngle",
        "type": "() => number"
      },
      {
        "name": "addEventListener",
        "type": "(type: string, listener: (event: any) => void) => void"
      },
      {
        "name": "hasEventListener",
        "type": "(type: string, listener: (event: any) => void) => void"
      },
      {
        "name": "removeEventListener",
        "type": "(type: string, listener: (event: any) => void) => void"
      },
      {
        "name": "dispatchEvent",
        "type": "(event: { type: string; target: any; }) => void"
      }
    ]
  },
  {
    "name": "OrthographicTrackballControls",
    "type": "typeof OrthographicTrackballControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "OrthographicTrackballControls"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Camera"
      },
      {
        "name": "domElement",
        "type": "HTMLElement"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "radius",
        "type": "number"
      },
      {
        "name": "rotateSpeed",
        "type": "number"
      },
      {
        "name": "zoomSpeed",
        "type": "number"
      },
      {
        "name": "panSpeed",
        "type": "number"
      },
      {
        "name": "noRotate",
        "type": "boolean"
      },
      {
        "name": "noZoom",
        "type": "boolean"
      },
      {
        "name": "noPan",
        "type": "boolean"
      },
      {
        "name": "noRoll",
        "type": "boolean"
      },
      {
        "name": "staticMoving",
        "type": "boolean"
      },
      {
        "name": "dynamicDampingFactor",
        "type": "number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "position0",
        "type": "Vector3"
      },
      {
        "name": "target0",
        "type": "Vector3"
      },
      {
        "name": "up0",
        "type": "Vector3"
      },
      {
        "name": "left0",
        "type": "number"
      },
      {
        "name": "right0",
        "type": "number"
      },
      {
        "name": "top0",
        "type": "number"
      },
      {
        "name": "bottom0",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "screen",
        "type": "{ left: number; top: number; width: number; height: number; }"
      },
      {
        "name": "keys",
        "type": "number[]"
      },
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      },
      {
        "name": "checkDistances",
        "type": "() => void"
      },
      {
        "name": "zoomCamera",
        "type": "() => void"
      },
      {
        "name": "panCamera",
        "type": "() => void"
      },
      {
        "name": "rotateCamera",
        "type": "() => void"
      },
      {
        "name": "handleResize",
        "type": "() => void"
      },
      {
        "name": "handleEvent",
        "type": "(event: any) => void"
      }
    ]
  },
  {
    "name": "RenderableObject",
    "type": "typeof RenderableObject",
    "constructors": [
      {
        "returnType": "RenderableObject"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "object",
        "type": "any"
      },
      {
        "name": "z",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "RenderableFace",
    "type": "typeof RenderableFace",
    "constructors": [
      {
        "returnType": "RenderableFace"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "v1",
        "type": "RenderableVertex"
      },
      {
        "name": "v2",
        "type": "RenderableVertex"
      },
      {
        "name": "v3",
        "type": "RenderableVertex"
      },
      {
        "name": "normalModel",
        "type": "Vector3"
      },
      {
        "name": "vertexNormalsLength",
        "type": "number"
      },
      {
        "name": "color",
        "type": "Color"
      },
      {
        "name": "material",
        "type": "Material"
      },
      {
        "name": "z",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "vertexNormalsModel",
        "type": "Vector3[]"
      },
      {
        "name": "uvs",
        "type": "Vector2[][]"
      }
    ]
  },
  {
    "name": "RenderableVertex",
    "type": "typeof RenderableVertex",
    "constructors": [
      {
        "returnType": "RenderableVertex"
      }
    ],
    "properties": [
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "positionWorld",
        "type": "Vector3"
      },
      {
        "name": "positionScreen",
        "type": "Vector4"
      },
      {
        "name": "visible",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "copy",
        "type": "(vertex: RenderableVertex) => void"
      }
    ]
  },
  {
    "name": "RenderableLine",
    "type": "typeof RenderableLine",
    "constructors": [
      {
        "returnType": "RenderableLine"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "v1",
        "type": "RenderableVertex"
      },
      {
        "name": "v2",
        "type": "RenderableVertex"
      },
      {
        "name": "material",
        "type": "Material"
      },
      {
        "name": "z",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "vertexColors",
        "type": "Color[]"
      }
    ]
  },
  {
    "name": "RenderableSprite",
    "type": "typeof RenderableSprite",
    "constructors": [
      {
        "returnType": "RenderableSprite"
      }
    ],
    "properties": [
      {
        "name": "id",
        "type": "number"
      },
      {
        "name": "object",
        "type": "any"
      },
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      },
      {
        "name": "z",
        "type": "number"
      },
      {
        "name": "rotation",
        "type": "number"
      },
      {
        "name": "scale",
        "type": "Vector2"
      },
      {
        "name": "material",
        "type": "Material"
      }
    ],
    "methods": []
  },
  {
    "name": "Projector",
    "type": "typeof Projector",
    "documentation": "Projects points between spaces.",
    "constructors": [
      {
        "returnType": "Projector"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "projectVector",
        "type": "(vector: Vector3, camera: Camera) => Vector3"
      },
      {
        "name": "unprojectVector",
        "type": "(vector: Vector3, camera: Camera) => Vector3"
      },
      {
        "name": "projectScene",
        "type": "(scene: Scene, camera: Camera, sortObjects: boolean, sortElements?: boolean) => { objects: Object...",
        "documentation": "Transforms a 3D scene object into 2D render data that can be rendered in a screen with your renderer of choice, projecting and clipping things out according to the used camera.\r\nIf the scene were a real scene, this method would be the equivalent of taking a picture with the camera (and developing the film would be the next step, using a Renderer)."
      }
    ]
  },
  {
    "name": "RenderPass",
    "type": "typeof RenderPass",
    "constructors": [
      {
        "parameters": [
          {
            "name": "scene",
            "type": "Scene"
          },
          {
            "name": "camera",
            "type": "Camera"
          },
          {
            "name": "overrideMaterial?",
            "type": "Material"
          },
          {
            "name": "clearColor?",
            "type": "string | number | Color"
          },
          {
            "name": "clearAlpha?",
            "type": "number"
          }
        ],
        "returnType": "RenderPass"
      }
    ],
    "properties": [
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "camera",
        "type": "Camera"
      },
      {
        "name": "overrideMaterial",
        "type": "Material"
      },
      {
        "name": "clearAlpha",
        "type": "number"
      },
      {
        "name": "oldClearColor",
        "type": "Color"
      },
      {
        "name": "oldClearAlpha",
        "type": "number"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "clear",
        "type": "boolean"
      },
      {
        "name": "needsSwap",
        "type": "boolean"
      }
    ],
    "methods": [
      {
        "name": "clearColor",
        "type": "string | number | Color"
      },
      {
        "name": "render",
        "type": "(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, delta: n..."
      }
    ]
  },
  {
    "name": "TrackballControls",
    "type": "typeof TrackballControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "TrackballControls"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Camera"
      },
      {
        "name": "domElement",
        "type": "HTMLElement"
      },
      {
        "name": "enabled",
        "type": "boolean"
      },
      {
        "name": "rotateSpeed",
        "type": "number"
      },
      {
        "name": "zoomSpeed",
        "type": "number"
      },
      {
        "name": "panSpeed",
        "type": "number"
      },
      {
        "name": "noRotate",
        "type": "boolean"
      },
      {
        "name": "noZoom",
        "type": "boolean"
      },
      {
        "name": "noPan",
        "type": "boolean"
      },
      {
        "name": "noRoll",
        "type": "boolean"
      },
      {
        "name": "staticMoving",
        "type": "boolean"
      },
      {
        "name": "dynamicDampingFactor",
        "type": "number"
      },
      {
        "name": "minDistance",
        "type": "number"
      },
      {
        "name": "maxDistance",
        "type": "number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "position0",
        "type": "Vector3"
      },
      {
        "name": "target0",
        "type": "Vector3"
      },
      {
        "name": "up0",
        "type": "Vector3"
      }
    ],
    "methods": [
      {
        "name": "screen",
        "type": "{ left: number; top: number; width: number; height: number; }"
      },
      {
        "name": "keys",
        "type": "number[]"
      },
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "reset",
        "type": "() => void"
      },
      {
        "name": "checkDistances",
        "type": "() => void"
      },
      {
        "name": "zoomCamera",
        "type": "() => void"
      },
      {
        "name": "panCamera",
        "type": "() => void"
      },
      {
        "name": "rotateCamera",
        "type": "() => void"
      },
      {
        "name": "handleResize",
        "type": "() => void"
      },
      {
        "name": "handleEvent",
        "type": "(event: any) => void"
      }
    ]
  },
  {
    "name": "TransformControls",
    "type": "typeof TransformControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "object",
            "type": "Camera"
          },
          {
            "name": "domElement?",
            "type": "HTMLElement"
          }
        ],
        "returnType": "TransformControls"
      }
    ],
    "properties": [
      {
        "name": "object",
        "type": "Object3D"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "() => void"
      },
      {
        "name": "detach",
        "type": "() => void"
      },
      {
        "name": "attach",
        "type": "(object: Object3D) => void"
      },
      {
        "name": "getMode",
        "type": "() => string"
      },
      {
        "name": "setMode",
        "type": "(mode: string) => void"
      },
      {
        "name": "setSnap",
        "type": "(snap: any) => void"
      },
      {
        "name": "setSize",
        "type": "(size: number) => void"
      },
      {
        "name": "setSpace",
        "type": "(space: string) => void"
      }
    ]
  },
  {
    "name": "VRDisplay",
    "type": "typeof VRDisplay",
    "constructors": [
      {
        "returnType": "VRDisplay"
      }
    ],
    "properties": [
      {
        "name": "isPresenting",
        "type": "boolean"
      },
      {
        "name": "capabilities",
        "type": "VRDisplayCapabilities",
        "documentation": "Dictionary of capabilities describing the VRDisplay."
      },
      {
        "name": "stageParameters",
        "type": "VRStageParameters",
        "documentation": "If this VRDisplay supports room-scale experiences, the optional\r\nstage attribute contains details on the room-scale parameters."
      },
      {
        "name": "displayId",
        "type": "number",
        "documentation": "An identifier for this distinct VRDisplay. Used as an\r\nassociation point in the Gamepad API."
      },
      {
        "name": "displayName",
        "type": "string",
        "documentation": "A display name, a user-readable name identifying it."
      },
      {
        "name": "depthNear",
        "type": "number",
        "documentation": "z-depth defining the near plane of the eye view frustum\r\nenables mapping of values in the render target depth\r\nattachment to scene coordinates. Initially set to 0.01."
      },
      {
        "name": "depthFar",
        "type": "number",
        "documentation": "z-depth defining the far plane of the eye view frustum\r\nenables mapping of values in the render target depth\r\nattachment to scene coordinates. Initially set to 10000.0."
      }
    ],
    "methods": [
      {
        "name": "getEyeParameters",
        "type": "(whichEye: VREye) => VREyeParameters"
      },
      {
        "name": "getFrameData",
        "type": "(frameData: VRFrameData) => boolean",
        "documentation": "Populates the passed VRFrameData with the information required to render\r\nthe current frame."
      },
      {
        "name": "getPose",
        "type": "() => VRPose",
        "documentation": "Return a VRPose containing the future predicted pose of the VRDisplay\r\nwhen the current frame will be presented. The value returned will not\r\nchange until JavaScript has returned control to the browser.\r\n\r\nThe VRPose will contain the position, orientation, velocity,\r\nand acceleration of each of these properties."
      },
      {
        "name": "getImmediatePose",
        "type": "() => VRPose",
        "documentation": "Return the current instantaneous pose of the VRDisplay, with no\r\nprediction applied."
      },
      {
        "name": "resetPose",
        "type": "() => void",
        "documentation": "Reset the pose for this display, treating its current position and\r\norientation as the \"origin/zero\" values. VRPose.position,\r\nVRPose.orientation, and VRStageParameters.sittingToStandingTransform may be\r\nupdated when calling resetPose(). This should be called in only\r\nsitting-space experiences."
      },
      {
        "name": "requestAnimationFrame",
        "type": "(callback: FrameRequestCallback) => number",
        "documentation": "The callback passed to `requestAnimationFrame` will be called\r\nany time a new frame should be rendered. When the VRDisplay is\r\npresenting the callback will be called at the native refresh\r\nrate of the HMD. When not presenting this function acts\r\nidentically to how window.requestAnimationFrame acts. Content should\r\nmake no assumptions of frame rate or vsync behavior as the HMD runs\r\nasynchronously from other displays and at differing refresh rates."
      },
      {
        "name": "cancelAnimationFrame",
        "type": "(handle: number) => void",
        "documentation": "Passing the value returned by `requestAnimationFrame` to\r\n`cancelAnimationFrame` will unregister the callback."
      },
      {
        "name": "requestPresent",
        "type": "(layers: VRLayer[]) => Promise<void>",
        "documentation": "Begin presenting to the VRDisplay. Must be called in response to a user gesture.\r\nRepeat calls while already presenting will update the VRLayers being displayed."
      },
      {
        "name": "exitPresent",
        "type": "() => Promise<void>",
        "documentation": "Stops presenting to the VRDisplay."
      },
      {
        "name": "getLayers",
        "type": "() => VRLayer[]",
        "documentation": "Get the layers currently being presented."
      },
      {
        "name": "submitFrame",
        "type": "(pose?: VRPose) => void",
        "documentation": "The VRLayer provided to the VRDisplay will be captured and presented\r\nin the HMD. Calling this function has the same effect on the source\r\ncanvas as any other operation that uses its source image, and canvases\r\ncreated without preserveDrawingBuffer set to true will be cleared."
      }
    ]
  },
  {
    "name": "VRDisplayCapabilities",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "hasOrientation",
        "type": "boolean"
      },
      {
        "name": "hasExternalDisplay",
        "type": "boolean"
      },
      {
        "name": "canPresent",
        "type": "boolean"
      },
      {
        "name": "maxLayers",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "VRFieldOfView",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "rightDegrees",
        "type": "number"
      },
      {
        "name": "downDegrees",
        "type": "number"
      },
      {
        "name": "leftDegrees",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "VRPose",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "position",
        "type": "Float32Array"
      },
      {
        "name": "linearVelocity",
        "type": "Float32Array"
      },
      {
        "name": "linearAcceleration",
        "type": "Float32Array"
      },
      {
        "name": "orientation",
        "type": "Float32Array"
      },
      {
        "name": "angularVelocity",
        "type": "Float32Array"
      },
      {
        "name": "angularAcceleration",
        "type": "Float32Array"
      }
    ],
    "methods": []
  },
  {
    "name": "VRFrameData",
    "type": "typeof VRFrameData",
    "constructors": [
      {
        "returnType": "VRFrameData"
      }
    ],
    "properties": [
      {
        "name": "leftProjectionMatrix",
        "type": "Float32Array"
      },
      {
        "name": "leftViewMatrix",
        "type": "Float32Array"
      },
      {
        "name": "rightProjectionMatrix",
        "type": "Float32Array"
      },
      {
        "name": "rightViewMatrix",
        "type": "Float32Array"
      },
      {
        "name": "pose",
        "type": "VRPose"
      }
    ],
    "methods": []
  },
  {
    "name": "VREyeParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "fieldOfView",
        "type": "VRFieldOfView"
      },
      {
        "name": "renderWidth",
        "type": "number"
      },
      {
        "name": "renderHeight",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "VRStageParameters",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "sizeX",
        "type": "number"
      },
      {
        "name": "sizeZ",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "Navigator",
    "type": "{ new (): Navigator; prototype: Navigator; }",
    "constructors": [
      {
        "returnType": "Navigator"
      }
    ],
    "properties": [
      {
        "name": "cookieEnabled",
        "type": "boolean"
      },
      {
        "name": "gamepadInputEmulation",
        "type": "GamepadInputEmulationType"
      },
      {
        "name": "language",
        "type": "string"
      },
      {
        "name": "maxTouchPoints",
        "type": "number"
      },
      {
        "name": "mimeTypes",
        "type": "MimeTypeArray"
      },
      {
        "name": "msManipulationViewsEnabled",
        "type": "boolean"
      },
      {
        "name": "msMaxTouchPoints",
        "type": "number"
      },
      {
        "name": "msPointerEnabled",
        "type": "boolean"
      },
      {
        "name": "plugins",
        "type": "PluginArray"
      },
      {
        "name": "pointerEnabled",
        "type": "boolean"
      },
      {
        "name": "serviceWorker",
        "type": "ServiceWorkerContainer"
      },
      {
        "name": "webdriver",
        "type": "boolean"
      },
      {
        "name": "hardwareConcurrency",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "languages",
        "type": "string[]"
      },
      {
        "name": "getGamepads",
        "type": "() => Gamepad[]"
      },
      {
        "name": "javaEnabled",
        "type": "() => boolean"
      },
      {
        "name": "msLaunchUri",
        "type": "(uri: string, successCallback?: MSLaunchUriCallback, noHandlerCallback?: MSLaunchUriCallback) => ..."
      },
      {
        "name": "requestMediaKeySystemAccess",
        "type": "(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]) => Promise<MediaKeySy..."
      },
      {
        "name": "vibrate",
        "type": "(pattern: number | number[]) => boolean"
      },
      {
        "name": "getVRDisplays",
        "type": "() => Promise<VRDisplay[]>"
      },
      {
        "name": "activeVRDisplays",
        "type": "VRDisplay[]"
      }
    ]
  },
  {
    "name": "Window",
    "type": "{ new (): Window; prototype: Window; }",
    "constructors": [
      {
        "returnType": "Window"
      }
    ],
    "properties": [
      {
        "name": "caches",
        "type": "CacheStorage"
      },
      {
        "name": "clientInformation",
        "type": "Navigator"
      },
      {
        "name": "closed",
        "type": "boolean"
      },
      {
        "name": "crypto",
        "type": "Crypto"
      },
      {
        "name": "defaultStatus",
        "type": "string"
      },
      {
        "name": "devicePixelRatio",
        "type": "number"
      },
      {
        "name": "document",
        "type": "Document"
      },
      {
        "name": "doNotTrack",
        "type": "string"
      },
      {
        "name": "event",
        "type": "Event"
      },
      {
        "name": "external",
        "type": "External"
      },
      {
        "name": "frameElement",
        "type": "Element"
      },
      {
        "name": "frames",
        "type": "Window"
      },
      {
        "name": "history",
        "type": "History"
      },
      {
        "name": "innerHeight",
        "type": "number"
      },
      {
        "name": "innerWidth",
        "type": "number"
      },
      {
        "name": "isSecureContext",
        "type": "boolean"
      },
      {
        "name": "length",
        "type": "number"
      },
      {
        "name": "location",
        "type": "Location"
      },
      {
        "name": "locationbar",
        "type": "BarProp"
      },
      {
        "name": "menubar",
        "type": "BarProp"
      },
      {
        "name": "msContentScript",
        "type": "ExtensionScriptApis"
      },
      {
        "name": "msCredentials",
        "type": "MSCredentials"
      },
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "navigator",
        "type": "Navigator"
      },
      {
        "name": "onerror",
        "type": "ErrorEventHandler"
      },
      {
        "name": "opener",
        "type": "any"
      },
      {
        "name": "outerHeight",
        "type": "number"
      },
      {
        "name": "outerWidth",
        "type": "number"
      },
      {
        "name": "pageXOffset",
        "type": "number"
      },
      {
        "name": "pageYOffset",
        "type": "number"
      },
      {
        "name": "parent",
        "type": "Window"
      },
      {
        "name": "performance",
        "type": "Performance"
      },
      {
        "name": "personalbar",
        "type": "BarProp"
      },
      {
        "name": "screen",
        "type": "Screen"
      },
      {
        "name": "screenLeft",
        "type": "number"
      },
      {
        "name": "screenTop",
        "type": "number"
      },
      {
        "name": "screenX",
        "type": "number"
      },
      {
        "name": "screenY",
        "type": "number"
      },
      {
        "name": "scrollbars",
        "type": "BarProp"
      },
      {
        "name": "scrollX",
        "type": "number"
      },
      {
        "name": "scrollY",
        "type": "number"
      },
      {
        "name": "self",
        "type": "Window"
      },
      {
        "name": "speechSynthesis",
        "type": "SpeechSynthesis"
      },
      {
        "name": "status",
        "type": "string"
      },
      {
        "name": "statusbar",
        "type": "BarProp"
      },
      {
        "name": "styleMedia",
        "type": "StyleMedia"
      },
      {
        "name": "toolbar",
        "type": "BarProp"
      },
      {
        "name": "top",
        "type": "Window"
      },
      {
        "name": "window",
        "type": "Window"
      },
      {
        "name": "customElements",
        "type": "CustomElementRegistry"
      }
    ],
    "methods": [
      {
        "name": "offscreenBuffering",
        "type": "string | boolean"
      },
      {
        "name": "onabort",
        "type": "(this: Window, ev: UIEvent) => any"
      },
      {
        "name": "onafterprint",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onbeforeprint",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onbeforeunload",
        "type": "(this: Window, ev: BeforeUnloadEvent) => any"
      },
      {
        "name": "onblur",
        "type": "(this: Window, ev: FocusEvent) => any"
      },
      {
        "name": "oncanplay",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "oncanplaythrough",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onchange",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onclick",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "oncompassneedscalibration",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "oncontextmenu",
        "type": "(this: Window, ev: PointerEvent) => any"
      },
      {
        "name": "ondblclick",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "ondevicelight",
        "type": "(this: Window, ev: DeviceLightEvent) => any"
      },
      {
        "name": "ondevicemotion",
        "type": "(this: Window, ev: DeviceMotionEvent) => any"
      },
      {
        "name": "ondeviceorientation",
        "type": "(this: Window, ev: DeviceOrientationEvent) => any"
      },
      {
        "name": "ondrag",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondragend",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondragenter",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondragleave",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondragover",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondragstart",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondrop",
        "type": "(this: Window, ev: DragEvent) => any"
      },
      {
        "name": "ondurationchange",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onemptied",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onended",
        "type": "(this: Window, ev: MediaStreamErrorEvent) => any"
      },
      {
        "name": "onfocus",
        "type": "(this: Window, ev: FocusEvent) => any"
      },
      {
        "name": "onhashchange",
        "type": "(this: Window, ev: HashChangeEvent) => any"
      },
      {
        "name": "oninput",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "oninvalid",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onkeydown",
        "type": "(this: Window, ev: KeyboardEvent) => any"
      },
      {
        "name": "onkeypress",
        "type": "(this: Window, ev: KeyboardEvent) => any"
      },
      {
        "name": "onkeyup",
        "type": "(this: Window, ev: KeyboardEvent) => any"
      },
      {
        "name": "onload",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onloadeddata",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onloadedmetadata",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onloadstart",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onmessage",
        "type": "(this: Window, ev: MessageEvent) => any"
      },
      {
        "name": "onmousedown",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmouseenter",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmouseleave",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmousemove",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmouseout",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmouseover",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmouseup",
        "type": "(this: Window, ev: MouseEvent) => any"
      },
      {
        "name": "onmousewheel",
        "type": "(this: Window, ev: WheelEvent) => any"
      },
      {
        "name": "onmsgesturechange",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsgesturedoubletap",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsgestureend",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsgesturehold",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsgesturestart",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsgesturetap",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmsinertiastart",
        "type": "(this: Window, ev: MSGestureEvent) => any"
      },
      {
        "name": "onmspointercancel",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerdown",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerenter",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerleave",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointermove",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerout",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerover",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onmspointerup",
        "type": "(this: Window, ev: MSPointerEvent) => any"
      },
      {
        "name": "onoffline",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "ononline",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onorientationchange",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onpagehide",
        "type": "(this: Window, ev: PageTransitionEvent) => any"
      },
      {
        "name": "onpageshow",
        "type": "(this: Window, ev: PageTransitionEvent) => any"
      },
      {
        "name": "onpause",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onplay",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onplaying",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onpopstate",
        "type": "(this: Window, ev: PopStateEvent) => any"
      },
      {
        "name": "onprogress",
        "type": "(this: Window, ev: ProgressEvent) => any"
      },
      {
        "name": "onratechange",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onreadystatechange",
        "type": "(this: Window, ev: ProgressEvent) => any"
      },
      {
        "name": "onreset",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onresize",
        "type": "(this: Window, ev: UIEvent) => any"
      },
      {
        "name": "onscroll",
        "type": "(this: Window, ev: UIEvent) => any"
      },
      {
        "name": "onseeked",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onseeking",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onselect",
        "type": "(this: Window, ev: UIEvent) => any"
      },
      {
        "name": "onstalled",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onstorage",
        "type": "(this: Window, ev: StorageEvent) => any"
      },
      {
        "name": "onsubmit",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onsuspend",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "ontimeupdate",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "ontouchcancel",
        "type": "(ev: TouchEvent) => any"
      },
      {
        "name": "ontouchend",
        "type": "(ev: TouchEvent) => any"
      },
      {
        "name": "ontouchmove",
        "type": "(ev: TouchEvent) => any"
      },
      {
        "name": "ontouchstart",
        "type": "(ev: TouchEvent) => any"
      },
      {
        "name": "onunload",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onvolumechange",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "onwaiting",
        "type": "(this: Window, ev: Event) => any"
      },
      {
        "name": "orientation",
        "type": "string | number"
      },
      {
        "name": "URL",
        "type": "{ new (url: string, base?: string): URL; prototype: URL; createObjectURL(object: any, options?: O..."
      },
      {
        "name": "URLSearchParams",
        "type": "{ new (init?: string | URLSearchParams): URLSearchParams; prototype: URLSearchParams; }"
      },
      {
        "name": "Blob",
        "type": "{ new (blobParts?: any[], options?: BlobPropertyBag): Blob; prototype: Blob; }"
      },
      {
        "name": "alert",
        "type": "(message?: any) => void"
      },
      {
        "name": "blur",
        "type": "() => void"
      },
      {
        "name": "cancelAnimationFrame",
        "type": "(handle: number) => void"
      },
      {
        "name": "captureEvents",
        "type": "() => void"
      },
      {
        "name": "close",
        "type": "() => void"
      },
      {
        "name": "confirm",
        "type": "(message?: string) => boolean"
      },
      {
        "name": "departFocus",
        "type": "(navigationReason: NavigationReason, origin: FocusNavigationOrigin) => void"
      },
      {
        "name": "focus",
        "type": "() => void"
      },
      {
        "name": "getComputedStyle",
        "type": "(elt: Element, pseudoElt?: string) => CSSStyleDeclaration"
      },
      {
        "name": "getMatchedCSSRules",
        "type": "(elt: Element, pseudoElt?: string) => CSSRuleList"
      },
      {
        "name": "getSelection",
        "type": "() => Selection"
      },
      {
        "name": "matchMedia",
        "type": "(mediaQuery: string) => MediaQueryList"
      },
      {
        "name": "moveBy",
        "type": "(x?: number, y?: number) => void"
      },
      {
        "name": "moveTo",
        "type": "(x?: number, y?: number) => void"
      },
      {
        "name": "msWriteProfilerMark",
        "type": "(profilerMarkName: string) => void"
      },
      {
        "name": "open",
        "type": "(url?: string, target?: string, features?: string, replace?: boolean) => Window"
      },
      {
        "name": "postMessage",
        "type": "(message: any, targetOrigin: string, transfer?: any[]) => void"
      },
      {
        "name": "print",
        "type": "() => void"
      },
      {
        "name": "prompt",
        "type": "(message?: string, _default?: string) => string"
      },
      {
        "name": "releaseEvents",
        "type": "() => void"
      },
      {
        "name": "requestAnimationFrame",
        "type": "(callback: FrameRequestCallback) => number"
      },
      {
        "name": "resizeBy",
        "type": "(x?: number, y?: number) => void"
      },
      {
        "name": "resizeTo",
        "type": "(x?: number, y?: number) => void"
      },
      {
        "name": "scroll",
        "type": "{ (x?: number, y?: number): void; (options?: ScrollToOptions): void; }"
      },
      {
        "name": "scrollBy",
        "type": "{ (x?: number, y?: number): void; (options?: ScrollToOptions): void; }"
      },
      {
        "name": "scrollTo",
        "type": "{ (x?: number, y?: number): void; (options?: ScrollToOptions): void; }"
      },
      {
        "name": "stop",
        "type": "() => void"
      },
      {
        "name": "webkitCancelAnimationFrame",
        "type": "(handle: number) => void"
      },
      {
        "name": "webkitConvertPointFromNodeToPage",
        "type": "(node: Node, pt: WebKitPoint) => WebKitPoint"
      },
      {
        "name": "webkitConvertPointFromPageToNode",
        "type": "(node: Node, pt: WebKitPoint) => WebKitPoint"
      },
      {
        "name": "webkitRequestAnimationFrame",
        "type": "(callback: FrameRequestCallback) => number"
      },
      {
        "name": "createImageBitmap",
        "type": "{ (image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageData | Blob | ImageBitma..."
      },
      {
        "name": "addEventListener",
        "type": "{ <K extends \"abort\" | \"afterprint\" | \"beforeprint\" | \"beforeunload\" | \"blur\" | \"canplay\" | \"canp..."
      },
      {
        "name": "onvrdisplayconnected",
        "type": "(ev: Event) => any"
      },
      {
        "name": "onvrdisplaydisconnected",
        "type": "(ev: Event) => any"
      },
      {
        "name": "onvrdisplaypresentchange",
        "type": "(ev: Event) => any"
      }
    ]
  },
  {
    "name": "Gamepad",
    "type": "{ new (): Gamepad; prototype: Gamepad; }",
    "constructors": [
      {
        "returnType": "Gamepad"
      }
    ],
    "properties": [
      {
        "name": "connected",
        "type": "boolean"
      },
      {
        "name": "id",
        "type": "string"
      },
      {
        "name": "index",
        "type": "number"
      },
      {
        "name": "mapping",
        "type": "string"
      },
      {
        "name": "timestamp",
        "type": "number"
      },
      {
        "name": "displayId",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "buttons",
        "type": "GamepadButton[]"
      }
    ]
  },
  {
    "name": "VRControls",
    "type": "typeof VRControls",
    "constructors": [
      {
        "parameters": [
          {
            "name": "camera",
            "type": "Camera"
          },
          {
            "name": "callback?",
            "type": "(param: string) => void"
          }
        ],
        "returnType": "VRControls"
      }
    ],
    "properties": [
      {
        "name": "scale",
        "type": "number"
      }
    ],
    "methods": [
      {
        "name": "update",
        "type": "() => void",
        "documentation": "Update VR Instance Tracking"
      },
      {
        "name": "zeroSensor",
        "type": "() => void"
      },
      {
        "name": "setVRDisplay",
        "type": "(display: VRDisplay) => void"
      }
    ]
  },
  {
    "name": "VREffect",
    "type": "typeof VREffect",
    "constructors": [
      {
        "parameters": [
          {
            "name": "renderer",
            "type": "Renderer"
          },
          {
            "name": "callback?",
            "type": "(params: string) => void"
          }
        ],
        "returnType": "VREffect"
      }
    ],
    "properties": [],
    "methods": [
      {
        "name": "render",
        "type": "(scene: Scene, camera: Camera) => void"
      },
      {
        "name": "setSize",
        "type": "(width: number, height: number) => void"
      },
      {
        "name": "setFullScreen",
        "type": "(flag: boolean) => void"
      },
      {
        "name": "startFullscreen",
        "type": "() => void"
      },
      {
        "name": "FovToNDCScaleOffset",
        "type": "(fov: VRFov) => VREffectOffset"
      },
      {
        "name": "FovPortToProjection",
        "type": "(fov: VRFov, rightHanded: boolean, zNear: number, zFar: number) => Matrix4"
      },
      {
        "name": "FovToProjection",
        "type": "(fov: VRFov, rightHanded: boolean, zNear: number, zFar: number) => Matrix4"
      },
      {
        "name": "setVRDisplay",
        "type": "(display: VRDisplay) => void"
      }
    ]
  },
  {
    "name": "VRFov",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "rightTan",
        "type": "number"
      },
      {
        "name": "upTan",
        "type": "number"
      },
      {
        "name": "downTan",
        "type": "number"
      }
    ],
    "methods": []
  },
  {
    "name": "VREffectOffset",
    "type": "any",
    "constructors": [],
    "properties": [
      {
        "name": "offset",
        "type": "number"
      }
    ],
    "methods": []
  }
]